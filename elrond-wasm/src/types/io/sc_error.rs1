// use crate::types::BoxedBytes;
// use alloc::string::String;
// use alloc::vec::Vec;
use elrond_codec::{DecodeError, EncodeError};

/// Contains a smart contract execution error message.
///
/// Implemented as a simple boxed slice, for performance reasons.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SCError(&'static [u8]);

impl SCError {
    #[inline]
    pub fn as_bytes(&self) -> &[u8] {
        self.0
    }
}

// impl From<BoxedBytes> for SCError {
//     #[inline]
//     fn from(boxed_bytes: BoxedBytes) -> Self {
//         SCError(boxed_bytes)
//     }
// }

// impl From<&str> for SCError {
//     #[inline]
//     fn from(s: &'static str) -> Self {
//         SCError(s)
//     }
// }

// impl From<String> for SCError {
//     #[inline]
//     fn from(s: String) -> Self {
//         // data copy is avoided:
//         // - String -> Vec<u8> via String::into_bytes is just a move
//         // - Vec<u8> -> Box<[u8]> -> BoxedBytes is also just a move
//         SCError(BoxedBytes::from(s.into_bytes()))
//     }
// }

impl From<&'static [u8]> for SCError {
    #[inline]
    fn from(byte_slice: &'static [u8]) -> Self {
        SCError(byte_slice)
    }
}

// impl From<Vec<u8>> for SCError {
//     #[inline]
//     fn from(v: Vec<u8>) -> Self {
//         SCError(BoxedBytes::from(v))
//     }
// }

impl From<EncodeError> for SCError {
    #[inline]
    fn from(err: EncodeError) -> Self {
        SCError(err.message_bytes())
    }
}

impl From<DecodeError> for SCError {
    #[inline]
    fn from(err: DecodeError) -> Self {
        SCError(err.message_bytes())
    }
}

impl From<!> for SCError {
    fn from(_: !) -> Self {
        unreachable!()
    }
}
