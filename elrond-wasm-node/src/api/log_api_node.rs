use crate::ArwenApiImpl;
use elrond_wasm::api::LogApi;
use elrond_wasm::types::ArgBuffer;

extern "C" {
	fn writeLog(pointer: *const u8, length: i32, topicPtr: *const u8, numTopics: i32);

	fn writeEventLog(
		numTopics: i32,
		topicLengthOffset: *const u8,
		topicOffset: *const u8,
		dataOffset: *const u8,
		dataLength: i32,
	);
}

const LEGACY_TOPIC_LENGTH: usize = 32;

/// Interface to only be used by code generated by the macros.
/// The smart contract code doesn't have access to these methods directly.
impl LogApi for ArwenApiImpl {
	fn write_event_log(&self, topics_buffer: &ArgBuffer, data: &[u8]) {
		unsafe {
			writeEventLog(
				topics_buffer.num_args() as i32,
				topics_buffer.arg_lengths_bytes_ptr(),
				topics_buffer.arg_data_ptr(),
				data.as_ptr(),
				data.len() as i32,
			);
		}
	}

	fn write_legacy_log(&self, topics: &[[u8; 32]], data: &[u8]) {
		let mut topics_raw = [0u8; LEGACY_TOPIC_LENGTH * 10]; // hopefully we never have more than 10 topics
		for i in 0..topics.len() {
			topics_raw[LEGACY_TOPIC_LENGTH * i..LEGACY_TOPIC_LENGTH * (i + 1)]
				.copy_from_slice(&topics[i]);
		}
		unsafe {
			writeLog(
				data.as_ptr(),
				data.len() as i32,
				topics_raw.as_ptr(),
				topics.len() as i32,
			);
		}
	}
}
