// Code generated by vmhooks generator. DO NOT EDIT.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!! AUTO-GENERATED FILE !!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

use std::ffi::c_void;

use multiversx_chain_vm_executor::{InstanceState, MemLength, MemPtr, VMHooks, VMHooksError};

use crate::host::vm_hooks::{TxContextVMHooksHandler, VMHooksDispatcher};

use super::WasmerProdInstanceState;

fn unwrap_or_set_breakpoint<R>(
    dispatcher: &mut VMHooksDispatcher<TxContextVMHooksHandler<WasmerProdInstanceState>>,
    result: Result<R, VMHooksError>,
) -> R
where
    R: Default,
{
    result.unwrap_or_else(|err| {
        let _ = dispatcher
            .handler
            .instance_state_ref
            .set_breakpoint_value(err);
        R::default()
    })
}

#[rustfmt::skip]
impl multiversx_chain_vm_executor::VMHooksLegacy for VMHooksDispatcher<TxContextVMHooksHandler<WasmerProdInstanceState>> {
    fn set_vm_hooks_ptr(&mut self, _vm_hooks_ptr: *mut c_void) {
    }

    fn get_gas_left(&mut self) -> i64 {
        let result = VMHooks::get_gas_left(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_sc_address(&mut self, result_offset: MemPtr) {
        let result = VMHooks::get_sc_address(self, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_owner_address(&mut self, result_offset: MemPtr) {
        let result = VMHooks::get_owner_address(self, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_shard_of_address(&mut self, address_offset: MemPtr) -> i32 {
        let result = VMHooks::get_shard_of_address(self, address_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn is_smart_contract(&mut self, address_offset: MemPtr) -> i32 {
        let result = VMHooks::is_smart_contract(self, address_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn signal_error(&mut self, message_offset: MemPtr, message_length: MemLength) {
        let result = VMHooks::signal_error(self, message_offset, message_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_external_balance(&mut self, address_offset: MemPtr, result_offset: MemPtr) {
        let result = VMHooks::get_external_balance(self, address_offset, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_block_hash(&mut self, nonce: i64, result_offset: MemPtr) -> i32 {
        let result = VMHooks::get_block_hash(self, nonce, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_balance(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64, result_offset: MemPtr) -> i32 {
        let result = VMHooks::get_esdt_balance(self, address_offset, token_id_offset, token_id_len, nonce, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_nft_name_length(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64) -> i32 {
        let result = VMHooks::get_esdt_nft_name_length(self, address_offset, token_id_offset, token_id_len, nonce);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_nft_attribute_length(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64) -> i32 {
        let result = VMHooks::get_esdt_nft_attribute_length(self, address_offset, token_id_offset, token_id_len, nonce);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_nft_uri_length(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64) -> i32 {
        let result = VMHooks::get_esdt_nft_uri_length(self, address_offset, token_id_offset, token_id_len, nonce);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_data(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64, value_handle: i32, properties_offset: MemPtr, hash_offset: MemPtr, name_offset: MemPtr, attributes_offset: MemPtr, creator_offset: MemPtr, royalties_handle: i32, uris_offset: MemPtr) -> i32 {
        let result = VMHooks::get_esdt_token_data(self, address_offset, token_id_offset, token_id_len, nonce, value_handle, properties_offset, hash_offset, name_offset, attributes_offset, creator_offset, royalties_handle, uris_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_local_roles(&mut self, token_id_handle: i32) -> i64 {
        let result = VMHooks::get_esdt_local_roles(self, token_id_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn validate_token_identifier(&mut self, token_id_handle: i32) -> i32 {
        let result = VMHooks::validate_token_identifier(self, token_id_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn transfer_value(&mut self, dest_offset: MemPtr, value_offset: MemPtr, data_offset: MemPtr, length: MemLength) -> i32 {
        let result = VMHooks::transfer_value(self, dest_offset, value_offset, data_offset, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn transfer_value_execute(&mut self, dest_offset: MemPtr, value_offset: MemPtr, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::transfer_value_execute(self, dest_offset, value_offset, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn transfer_esdt_execute(&mut self, dest_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, value_offset: MemPtr, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::transfer_esdt_execute(self, dest_offset, token_id_offset, token_id_len, value_offset, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn transfer_esdt_nft_execute(&mut self, dest_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, value_offset: MemPtr, nonce: i64, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::transfer_esdt_nft_execute(self, dest_offset, token_id_offset, token_id_len, value_offset, nonce, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn multi_transfer_esdt_nft_execute(&mut self, dest_offset: MemPtr, num_token_transfers: i32, token_transfers_args_length_offset: MemPtr, token_transfer_data_offset: MemPtr, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::multi_transfer_esdt_nft_execute(self, dest_offset, num_token_transfers, token_transfers_args_length_offset, token_transfer_data_offset, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn create_async_call(&mut self, dest_offset: MemPtr, value_offset: MemPtr, data_offset: MemPtr, data_length: MemLength, success_offset: MemPtr, success_length: MemLength, error_offset: MemPtr, error_length: MemLength, gas: i64, extra_gas_for_callback: i64) -> i32 {
        let result = VMHooks::create_async_call(self, dest_offset, value_offset, data_offset, data_length, success_offset, success_length, error_offset, error_length, gas, extra_gas_for_callback);
        unwrap_or_set_breakpoint(self, result)
    }

    fn set_async_context_callback(&mut self, callback: MemPtr, callback_length: MemLength, data: MemPtr, data_length: MemLength, gas: i64) -> i32 {
        let result = VMHooks::set_async_context_callback(self, callback, callback_length, data, data_length, gas);
        unwrap_or_set_breakpoint(self, result)
    }

    fn upgrade_contract(&mut self, dest_offset: MemPtr, gas_limit: i64, value_offset: MemPtr, code_offset: MemPtr, code_metadata_offset: MemPtr, length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) {
        let result = VMHooks::upgrade_contract(self, dest_offset, gas_limit, value_offset, code_offset, code_metadata_offset, length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn upgrade_from_source_contract(&mut self, dest_offset: MemPtr, gas_limit: i64, value_offset: MemPtr, source_contract_address_offset: MemPtr, code_metadata_offset: MemPtr, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) {
        let result = VMHooks::upgrade_from_source_contract(self, dest_offset, gas_limit, value_offset, source_contract_address_offset, code_metadata_offset, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn delete_contract(&mut self, dest_offset: MemPtr, gas_limit: i64, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) {
        let result = VMHooks::delete_contract(self, dest_offset, gas_limit, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn async_call(&mut self, dest_offset: MemPtr, value_offset: MemPtr, data_offset: MemPtr, length: MemLength) {
        let result = VMHooks::async_call(self, dest_offset, value_offset, data_offset, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_argument_length(&mut self, id: i32) -> i32 {
        let result = VMHooks::get_argument_length(self, id);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_argument(&mut self, id: i32, arg_offset: MemPtr) -> i32 {
        let result = VMHooks::get_argument(self, id, arg_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_function(&mut self, function_offset: MemPtr) -> i32 {
        let result = VMHooks::get_function(self, function_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_num_arguments(&mut self) -> i32 {
        let result = VMHooks::get_num_arguments(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn storage_store(&mut self, key_offset: MemPtr, key_length: MemLength, data_offset: MemPtr, data_length: MemLength) -> i32 {
        let result = VMHooks::storage_store(self, key_offset, key_length, data_offset, data_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn storage_load_length(&mut self, key_offset: MemPtr, key_length: MemLength) -> i32 {
        let result = VMHooks::storage_load_length(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn storage_load_from_address(&mut self, address_offset: MemPtr, key_offset: MemPtr, key_length: MemLength, data_offset: MemPtr) -> i32 {
        let result = VMHooks::storage_load_from_address(self, address_offset, key_offset, key_length, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn storage_load(&mut self, key_offset: MemPtr, key_length: MemLength, data_offset: MemPtr) -> i32 {
        let result = VMHooks::storage_load(self, key_offset, key_length, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn set_storage_lock(&mut self, key_offset: MemPtr, key_length: MemLength, lock_timestamp: i64) -> i32 {
        let result = VMHooks::set_storage_lock(self, key_offset, key_length, lock_timestamp);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_storage_lock(&mut self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        let result = VMHooks::get_storage_lock(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn is_storage_locked(&mut self, key_offset: MemPtr, key_length: MemLength) -> i32 {
        let result = VMHooks::is_storage_locked(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn clear_storage_lock(&mut self, key_offset: MemPtr, key_length: MemLength) -> i32 {
        let result = VMHooks::clear_storage_lock(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_caller(&mut self, result_offset: MemPtr) {
        let result = VMHooks::get_caller(self, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn check_no_payment(&mut self) {
        let result = VMHooks::check_no_payment(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_call_value(&mut self, result_offset: MemPtr) -> i32 {
        let result = VMHooks::get_call_value(self, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_value(&mut self, result_offset: MemPtr) -> i32 {
        let result = VMHooks::get_esdt_value(self, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_value_by_index(&mut self, result_offset: MemPtr, index: i32) -> i32 {
        let result = VMHooks::get_esdt_value_by_index(self, result_offset, index);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_name(&mut self, result_offset: MemPtr) -> i32 {
        let result = VMHooks::get_esdt_token_name(self, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_name_by_index(&mut self, result_offset: MemPtr, index: i32) -> i32 {
        let result = VMHooks::get_esdt_token_name_by_index(self, result_offset, index);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_nonce(&mut self) -> i64 {
        let result = VMHooks::get_esdt_token_nonce(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_nonce_by_index(&mut self, index: i32) -> i64 {
        let result = VMHooks::get_esdt_token_nonce_by_index(self, index);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_current_esdt_nft_nonce(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength) -> i64 {
        let result = VMHooks::get_current_esdt_nft_nonce(self, address_offset, token_id_offset, token_id_len);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_type(&mut self) -> i32 {
        let result = VMHooks::get_esdt_token_type(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_esdt_token_type_by_index(&mut self, index: i32) -> i32 {
        let result = VMHooks::get_esdt_token_type_by_index(self, index);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_num_esdt_transfers(&mut self) -> i32 {
        let result = VMHooks::get_num_esdt_transfers(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_call_value_token_name(&mut self, call_value_offset: MemPtr, token_name_offset: MemPtr) -> i32 {
        let result = VMHooks::get_call_value_token_name(self, call_value_offset, token_name_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_call_value_token_name_by_index(&mut self, call_value_offset: MemPtr, token_name_offset: MemPtr, index: i32) -> i32 {
        let result = VMHooks::get_call_value_token_name_by_index(self, call_value_offset, token_name_offset, index);
        unwrap_or_set_breakpoint(self, result)
    }

    fn is_reserved_function_name(&mut self, name_handle: i32) -> i32 {
        let result = VMHooks::is_reserved_function_name(self, name_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn write_log(&mut self, data_pointer: MemPtr, data_length: MemLength, topic_ptr: MemPtr, num_topics: i32) {
        let result = VMHooks::write_log(self, data_pointer, data_length, topic_ptr, num_topics);
        unwrap_or_set_breakpoint(self, result)
    }

    fn write_event_log(&mut self, num_topics: i32, topic_lengths_offset: MemPtr, topic_offset: MemPtr, data_offset: MemPtr, data_length: MemLength) {
        let result = VMHooks::write_event_log(self, num_topics, topic_lengths_offset, topic_offset, data_offset, data_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_block_timestamp(&mut self) -> i64 {
        let result = VMHooks::get_block_timestamp(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_block_nonce(&mut self) -> i64 {
        let result = VMHooks::get_block_nonce(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_block_round(&mut self) -> i64 {
        let result = VMHooks::get_block_round(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_block_epoch(&mut self) -> i64 {
        let result = VMHooks::get_block_epoch(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_block_random_seed(&mut self, pointer: MemPtr) {
        let result = VMHooks::get_block_random_seed(self, pointer);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_state_root_hash(&mut self, pointer: MemPtr) {
        let result = VMHooks::get_state_root_hash(self, pointer);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_prev_block_timestamp(&mut self) -> i64 {
        let result = VMHooks::get_prev_block_timestamp(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_prev_block_nonce(&mut self) -> i64 {
        let result = VMHooks::get_prev_block_nonce(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_prev_block_round(&mut self) -> i64 {
        let result = VMHooks::get_prev_block_round(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_prev_block_epoch(&mut self) -> i64 {
        let result = VMHooks::get_prev_block_epoch(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_prev_block_random_seed(&mut self, pointer: MemPtr) {
        let result = VMHooks::get_prev_block_random_seed(self, pointer);
        unwrap_or_set_breakpoint(self, result)
    }

    fn finish(&mut self, pointer: MemPtr, length: MemLength) {
        let result = VMHooks::finish(self, pointer, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn execute_on_same_context(&mut self, gas_limit: i64, address_offset: MemPtr, value_offset: MemPtr, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::execute_on_same_context(self, gas_limit, address_offset, value_offset, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn execute_on_dest_context(&mut self, gas_limit: i64, address_offset: MemPtr, value_offset: MemPtr, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::execute_on_dest_context(self, gas_limit, address_offset, value_offset, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn execute_read_only(&mut self, gas_limit: i64, address_offset: MemPtr, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::execute_read_only(self, gas_limit, address_offset, function_offset, function_length, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn create_contract(&mut self, gas_limit: i64, value_offset: MemPtr, code_offset: MemPtr, code_metadata_offset: MemPtr, length: MemLength, result_offset: MemPtr, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::create_contract(self, gas_limit, value_offset, code_offset, code_metadata_offset, length, result_offset, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn deploy_from_source_contract(&mut self, gas_limit: i64, value_offset: MemPtr, source_contract_address_offset: MemPtr, code_metadata_offset: MemPtr, result_address_offset: MemPtr, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        let result = VMHooks::deploy_from_source_contract(self, gas_limit, value_offset, source_contract_address_offset, code_metadata_offset, result_address_offset, num_arguments, arguments_length_offset, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_num_return_data(&mut self) -> i32 {
        let result = VMHooks::get_num_return_data(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_return_data_size(&mut self, result_id: i32) -> i32 {
        let result = VMHooks::get_return_data_size(self, result_id);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_return_data(&mut self, result_id: i32, data_offset: MemPtr) -> i32 {
        let result = VMHooks::get_return_data(self, result_id, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn clean_return_data(&mut self) {
        let result = VMHooks::clean_return_data(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn delete_from_return_data(&mut self, result_id: i32) {
        let result = VMHooks::delete_from_return_data(self, result_id);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_original_tx_hash(&mut self, data_offset: MemPtr) {
        let result = VMHooks::get_original_tx_hash(self, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_current_tx_hash(&mut self, data_offset: MemPtr) {
        let result = VMHooks::get_current_tx_hash(self, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_prev_tx_hash(&mut self, data_offset: MemPtr) {
        let result = VMHooks::get_prev_tx_hash(self, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_sc_address(&mut self, destination_handle: i32) {
        let result = VMHooks::managed_sc_address(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_owner_address(&mut self, destination_handle: i32) {
        let result = VMHooks::managed_owner_address(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_caller(&mut self, destination_handle: i32) {
        let result = VMHooks::managed_caller(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_original_caller_addr(&mut self, destination_handle: i32) {
        let result = VMHooks::managed_get_original_caller_addr(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_relayer_addr(&mut self, destination_handle: i32) {
        let result = VMHooks::managed_get_relayer_addr(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_signal_error(&mut self, err_handle: i32) {
        let result = VMHooks::managed_signal_error(self, err_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_write_log(&mut self, topics_handle: i32, data_handle: i32) {
        let result = VMHooks::managed_write_log(self, topics_handle, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_original_tx_hash(&mut self, result_handle: i32) {
        let result = VMHooks::managed_get_original_tx_hash(self, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_state_root_hash(&mut self, result_handle: i32) {
        let result = VMHooks::managed_get_state_root_hash(self, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_block_random_seed(&mut self, result_handle: i32) {
        let result = VMHooks::managed_get_block_random_seed(self, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_prev_block_random_seed(&mut self, result_handle: i32) {
        let result = VMHooks::managed_get_prev_block_random_seed(self, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_return_data(&mut self, result_id: i32, result_handle: i32) {
        let result = VMHooks::managed_get_return_data(self, result_id, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_multi_esdt_call_value(&mut self, multi_call_value_handle: i32) {
        let result = VMHooks::managed_get_multi_esdt_call_value(self, multi_call_value_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_back_transfers(&mut self, esdt_transfers_value_handle: i32, egld_value_handle: i32) {
        let result = VMHooks::managed_get_back_transfers(self, esdt_transfers_value_handle, egld_value_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_esdt_balance(&mut self, address_handle: i32, token_id_handle: i32, nonce: i64, value_handle: i32) {
        let result = VMHooks::managed_get_esdt_balance(self, address_handle, token_id_handle, nonce, value_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_esdt_token_data(&mut self, address_handle: i32, token_id_handle: i32, nonce: i64, value_handle: i32, properties_handle: i32, hash_handle: i32, name_handle: i32, attributes_handle: i32, creator_handle: i32, royalties_handle: i32, uris_handle: i32) {
        let result = VMHooks::managed_get_esdt_token_data(self, address_handle, token_id_handle, nonce, value_handle, properties_handle, hash_handle, name_handle, attributes_handle, creator_handle, royalties_handle, uris_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_async_call(&mut self, dest_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32) {
        let result = VMHooks::managed_async_call(self, dest_handle, value_handle, function_handle, arguments_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_create_async_call(&mut self, dest_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, success_offset: MemPtr, success_length: MemLength, error_offset: MemPtr, error_length: MemLength, gas: i64, extra_gas_for_callback: i64, callback_closure_handle: i32) -> i32 {
        let result = VMHooks::managed_create_async_call(self, dest_handle, value_handle, function_handle, arguments_handle, success_offset, success_length, error_offset, error_length, gas, extra_gas_for_callback, callback_closure_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_callback_closure(&mut self, callback_closure_handle: i32) {
        let result = VMHooks::managed_get_callback_closure(self, callback_closure_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_upgrade_from_source_contract(&mut self, dest_handle: i32, gas: i64, value_handle: i32, address_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_handle: i32) {
        let result = VMHooks::managed_upgrade_from_source_contract(self, dest_handle, gas, value_handle, address_handle, code_metadata_handle, arguments_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_upgrade_contract(&mut self, dest_handle: i32, gas: i64, value_handle: i32, code_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_handle: i32) {
        let result = VMHooks::managed_upgrade_contract(self, dest_handle, gas, value_handle, code_handle, code_metadata_handle, arguments_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_delete_contract(&mut self, dest_handle: i32, gas_limit: i64, arguments_handle: i32) {
        let result = VMHooks::managed_delete_contract(self, dest_handle, gas_limit, arguments_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_deploy_from_source_contract(&mut self, gas: i64, value_handle: i32, address_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_address_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_deploy_from_source_contract(self, gas, value_handle, address_handle, code_metadata_handle, arguments_handle, result_address_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_create_contract(&mut self, gas: i64, value_handle: i32, code_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_address_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_create_contract(self, gas, value_handle, code_handle, code_metadata_handle, arguments_handle, result_address_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_execute_read_only(&mut self, gas: i64, address_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_execute_read_only(self, gas, address_handle, function_handle, arguments_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_execute_on_same_context(&mut self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_execute_on_same_context(self, gas, address_handle, value_handle, function_handle, arguments_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_execute_on_dest_context(&mut self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_execute_on_dest_context(self, gas, address_handle, value_handle, function_handle, arguments_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_multi_transfer_esdt_nft_execute(&mut self, dst_handle: i32, token_transfers_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        let result = VMHooks::managed_multi_transfer_esdt_nft_execute(self, dst_handle, token_transfers_handle, gas_limit, function_handle, arguments_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_multi_transfer_esdt_nft_execute_by_user(&mut self, user_handle: i32, dst_handle: i32, token_transfers_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        let result = VMHooks::managed_multi_transfer_esdt_nft_execute_by_user(self, user_handle, dst_handle, token_transfers_handle, gas_limit, function_handle, arguments_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_transfer_value_execute(&mut self, dst_handle: i32, value_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        let result = VMHooks::managed_transfer_value_execute(self, dst_handle, value_handle, gas_limit, function_handle, arguments_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_is_esdt_frozen(&mut self, address_handle: i32, token_id_handle: i32, nonce: i64) -> i32 {
        let result = VMHooks::managed_is_esdt_frozen(self, address_handle, token_id_handle, nonce);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_is_esdt_limited_transfer(&mut self, token_id_handle: i32) -> i32 {
        let result = VMHooks::managed_is_esdt_limited_transfer(self, token_id_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_is_esdt_paused(&mut self, token_id_handle: i32) -> i32 {
        let result = VMHooks::managed_is_esdt_paused(self, token_id_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_buffer_to_hex(&mut self, source_handle: i32, dest_handle: i32) {
        let result = VMHooks::managed_buffer_to_hex(self, source_handle, dest_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_get_code_metadata(&mut self, address_handle: i32, response_handle: i32) {
        let result = VMHooks::managed_get_code_metadata(self, address_handle, response_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_is_builtin_function(&mut self, function_name_handle: i32) -> i32 {
        let result = VMHooks::managed_is_builtin_function(self, function_name_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_new_from_parts(&mut self, integral_part: i32, fractional_part: i32, exponent: i32) -> i32 {
        let result = VMHooks::big_float_new_from_parts(self, integral_part, fractional_part, exponent);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_new_from_frac(&mut self, numerator: i64, denominator: i64) -> i32 {
        let result = VMHooks::big_float_new_from_frac(self, numerator, denominator);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_new_from_sci(&mut self, significand: i64, exponent: i64) -> i32 {
        let result = VMHooks::big_float_new_from_sci(self, significand, exponent);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_add(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_float_add(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_sub(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_float_sub(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_mul(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_float_mul(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_div(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_float_div(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_neg(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_neg(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_clone(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_clone(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_cmp(&mut self, op1_handle: i32, op2_handle: i32) -> i32 {
        let result = VMHooks::big_float_cmp(self, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_abs(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_abs(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_sign(&mut self, op_handle: i32) -> i32 {
        let result = VMHooks::big_float_sign(self, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_sqrt(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_sqrt(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_pow(&mut self, destination_handle: i32, op_handle: i32, exponent: i32) {
        let result = VMHooks::big_float_pow(self, destination_handle, op_handle, exponent);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_floor(&mut self, dest_big_int_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_floor(self, dest_big_int_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_ceil(&mut self, dest_big_int_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_ceil(self, dest_big_int_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_truncate(&mut self, dest_big_int_handle: i32, op_handle: i32) {
        let result = VMHooks::big_float_truncate(self, dest_big_int_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_set_int64(&mut self, destination_handle: i32, value: i64) {
        let result = VMHooks::big_float_set_int64(self, destination_handle, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_is_int(&mut self, op_handle: i32) -> i32 {
        let result = VMHooks::big_float_is_int(self, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_set_big_int(&mut self, destination_handle: i32, big_int_handle: i32) {
        let result = VMHooks::big_float_set_big_int(self, destination_handle, big_int_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_get_const_pi(&mut self, destination_handle: i32) {
        let result = VMHooks::big_float_get_const_pi(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_float_get_const_e(&mut self, destination_handle: i32) {
        let result = VMHooks::big_float_get_const_e(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_unsigned_argument(&mut self, id: i32, destination_handle: i32) {
        let result = VMHooks::big_int_get_unsigned_argument(self, id, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_signed_argument(&mut self, id: i32, destination_handle: i32) {
        let result = VMHooks::big_int_get_signed_argument(self, id, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_storage_store_unsigned(&mut self, key_offset: MemPtr, key_length: MemLength, source_handle: i32) -> i32 {
        let result = VMHooks::big_int_storage_store_unsigned(self, key_offset, key_length, source_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_storage_load_unsigned(&mut self, key_offset: MemPtr, key_length: MemLength, destination_handle: i32) -> i32 {
        let result = VMHooks::big_int_storage_load_unsigned(self, key_offset, key_length, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_call_value(&mut self, destination_handle: i32) {
        let result = VMHooks::big_int_get_call_value(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_esdt_call_value(&mut self, destination: i32) {
        let result = VMHooks::big_int_get_esdt_call_value(self, destination);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_esdt_call_value_by_index(&mut self, destination_handle: i32, index: i32) {
        let result = VMHooks::big_int_get_esdt_call_value_by_index(self, destination_handle, index);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_external_balance(&mut self, address_offset: MemPtr, result: i32) {
        let result = VMHooks::big_int_get_external_balance(self, address_offset, result);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_esdt_external_balance(&mut self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64, result_handle: i32) {
        let result = VMHooks::big_int_get_esdt_external_balance(self, address_offset, token_id_offset, token_id_len, nonce, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_new(&mut self, small_value: i64) -> i32 {
        let result = VMHooks::big_int_new(self, small_value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_unsigned_byte_length(&mut self, reference_handle: i32) -> i32 {
        let result = VMHooks::big_int_unsigned_byte_length(self, reference_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_signed_byte_length(&mut self, reference_handle: i32) -> i32 {
        let result = VMHooks::big_int_signed_byte_length(self, reference_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_unsigned_bytes(&mut self, reference_handle: i32, byte_offset: MemPtr) -> i32 {
        let result = VMHooks::big_int_get_unsigned_bytes(self, reference_handle, byte_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_signed_bytes(&mut self, reference_handle: i32, byte_offset: MemPtr) -> i32 {
        let result = VMHooks::big_int_get_signed_bytes(self, reference_handle, byte_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_set_unsigned_bytes(&mut self, destination_handle: i32, byte_offset: MemPtr, byte_length: MemLength) {
        let result = VMHooks::big_int_set_unsigned_bytes(self, destination_handle, byte_offset, byte_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_set_signed_bytes(&mut self, destination_handle: i32, byte_offset: MemPtr, byte_length: MemLength) {
        let result = VMHooks::big_int_set_signed_bytes(self, destination_handle, byte_offset, byte_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_is_int64(&mut self, destination_handle: i32) -> i32 {
        let result = VMHooks::big_int_is_int64(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_get_int64(&mut self, destination_handle: i32) -> i64 {
        let result = VMHooks::big_int_get_int64(self, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_set_int64(&mut self, destination_handle: i32, value: i64) {
        let result = VMHooks::big_int_set_int64(self, destination_handle, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_add(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_add(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_sub(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_sub(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_mul(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_mul(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_tdiv(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_tdiv(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_tmod(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_tmod(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_ediv(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_ediv(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_emod(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_emod(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_sqrt(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_int_sqrt(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_pow(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_pow(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_log2(&mut self, op1_handle: i32) -> i32 {
        let result = VMHooks::big_int_log2(self, op1_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_abs(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_int_abs(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_neg(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_int_neg(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_sign(&mut self, op_handle: i32) -> i32 {
        let result = VMHooks::big_int_sign(self, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_cmp(&mut self, op1_handle: i32, op2_handle: i32) -> i32 {
        let result = VMHooks::big_int_cmp(self, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_not(&mut self, destination_handle: i32, op_handle: i32) {
        let result = VMHooks::big_int_not(self, destination_handle, op_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_and(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_and(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_or(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_or(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_xor(&mut self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        let result = VMHooks::big_int_xor(self, destination_handle, op1_handle, op2_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_shr(&mut self, destination_handle: i32, op_handle: i32, bits: i32) {
        let result = VMHooks::big_int_shr(self, destination_handle, op_handle, bits);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_shl(&mut self, destination_handle: i32, op_handle: i32, bits: i32) {
        let result = VMHooks::big_int_shl(self, destination_handle, op_handle, bits);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_finish_unsigned(&mut self, reference_handle: i32) {
        let result = VMHooks::big_int_finish_unsigned(self, reference_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_finish_signed(&mut self, reference_handle: i32) {
        let result = VMHooks::big_int_finish_signed(self, reference_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn big_int_to_string(&mut self, big_int_handle: i32, destination_handle: i32) {
        let result = VMHooks::big_int_to_string(self, big_int_handle, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_new(&mut self) -> i32 {
        let result = VMHooks::mbuffer_new(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_new_from_bytes(&mut self, data_offset: MemPtr, data_length: MemLength) -> i32 {
        let result = VMHooks::mbuffer_new_from_bytes(self, data_offset, data_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_get_length(&mut self, m_buffer_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_get_length(self, m_buffer_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_get_bytes(&mut self, m_buffer_handle: i32, result_offset: MemPtr) -> i32 {
        let result = VMHooks::mbuffer_get_bytes(self, m_buffer_handle, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_get_byte_slice(&mut self, source_handle: i32, starting_position: i32, slice_length: i32, result_offset: MemPtr) -> i32 {
        let result = VMHooks::mbuffer_get_byte_slice(self, source_handle, starting_position, slice_length, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_copy_byte_slice(&mut self, source_handle: i32, starting_position: i32, slice_length: i32, destination_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_copy_byte_slice(self, source_handle, starting_position, slice_length, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_eq(&mut self, m_buffer_handle1: i32, m_buffer_handle2: i32) -> i32 {
        let result = VMHooks::mbuffer_eq(self, m_buffer_handle1, m_buffer_handle2);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_set_bytes(&mut self, m_buffer_handle: i32, data_offset: MemPtr, data_length: MemLength) -> i32 {
        let result = VMHooks::mbuffer_set_bytes(self, m_buffer_handle, data_offset, data_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_set_byte_slice(&mut self, m_buffer_handle: i32, starting_position: i32, data_length: MemLength, data_offset: MemPtr) -> i32 {
        let result = VMHooks::mbuffer_set_byte_slice(self, m_buffer_handle, starting_position, data_length, data_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_append(&mut self, accumulator_handle: i32, data_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_append(self, accumulator_handle, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_append_bytes(&mut self, accumulator_handle: i32, data_offset: MemPtr, data_length: MemLength) -> i32 {
        let result = VMHooks::mbuffer_append_bytes(self, accumulator_handle, data_offset, data_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_to_big_int_unsigned(&mut self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_to_big_int_unsigned(self, m_buffer_handle, big_int_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_to_big_int_signed(&mut self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_to_big_int_signed(self, m_buffer_handle, big_int_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_from_big_int_unsigned(&mut self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_from_big_int_unsigned(self, m_buffer_handle, big_int_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_from_big_int_signed(&mut self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_from_big_int_signed(self, m_buffer_handle, big_int_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_to_big_float(&mut self, m_buffer_handle: i32, big_float_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_to_big_float(self, m_buffer_handle, big_float_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_from_big_float(&mut self, m_buffer_handle: i32, big_float_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_from_big_float(self, m_buffer_handle, big_float_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_storage_store(&mut self, key_handle: i32, source_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_storage_store(self, key_handle, source_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_storage_load(&mut self, key_handle: i32, destination_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_storage_load(self, key_handle, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_storage_load_from_address(&mut self, address_handle: i32, key_handle: i32, destination_handle: i32) {
        let result = VMHooks::mbuffer_storage_load_from_address(self, address_handle, key_handle, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_get_argument(&mut self, id: i32, destination_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_get_argument(self, id, destination_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_finish(&mut self, source_handle: i32) -> i32 {
        let result = VMHooks::mbuffer_finish(self, source_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn mbuffer_set_random(&mut self, destination_handle: i32, length: i32) -> i32 {
        let result = VMHooks::mbuffer_set_random(self, destination_handle, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_map_new(&mut self) -> i32 {
        let result = VMHooks::managed_map_new(self);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_map_put(&mut self, m_map_handle: i32, key_handle: i32, value_handle: i32) -> i32 {
        let result = VMHooks::managed_map_put(self, m_map_handle, key_handle, value_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_map_get(&mut self, m_map_handle: i32, key_handle: i32, out_value_handle: i32) -> i32 {
        let result = VMHooks::managed_map_get(self, m_map_handle, key_handle, out_value_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_map_remove(&mut self, m_map_handle: i32, key_handle: i32, out_value_handle: i32) -> i32 {
        let result = VMHooks::managed_map_remove(self, m_map_handle, key_handle, out_value_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_map_contains(&mut self, m_map_handle: i32, key_handle: i32) -> i32 {
        let result = VMHooks::managed_map_contains(self, m_map_handle, key_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_get_unsigned_argument(&mut self, id: i32) -> i64 {
        let result = VMHooks::small_int_get_unsigned_argument(self, id);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_get_signed_argument(&mut self, id: i32) -> i64 {
        let result = VMHooks::small_int_get_signed_argument(self, id);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_finish_unsigned(&mut self, value: i64) {
        let result = VMHooks::small_int_finish_unsigned(self, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_finish_signed(&mut self, value: i64) {
        let result = VMHooks::small_int_finish_signed(self, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_storage_store_unsigned(&mut self, key_offset: MemPtr, key_length: MemLength, value: i64) -> i32 {
        let result = VMHooks::small_int_storage_store_unsigned(self, key_offset, key_length, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_storage_store_signed(&mut self, key_offset: MemPtr, key_length: MemLength, value: i64) -> i32 {
        let result = VMHooks::small_int_storage_store_signed(self, key_offset, key_length, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_storage_load_unsigned(&mut self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        let result = VMHooks::small_int_storage_load_unsigned(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn small_int_storage_load_signed(&mut self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        let result = VMHooks::small_int_storage_load_signed(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn int64get_argument(&mut self, id: i32) -> i64 {
        let result = VMHooks::int64get_argument(self, id);
        unwrap_or_set_breakpoint(self, result)
    }

    fn int64finish(&mut self, value: i64) {
        let result = VMHooks::int64finish(self, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn int64storage_store(&mut self, key_offset: MemPtr, key_length: MemLength, value: i64) -> i32 {
        let result = VMHooks::int64storage_store(self, key_offset, key_length, value);
        unwrap_or_set_breakpoint(self, result)
    }

    fn int64storage_load(&mut self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        let result = VMHooks::int64storage_load(self, key_offset, key_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn sha256(&mut self, data_offset: MemPtr, length: MemLength, result_offset: MemPtr) -> i32 {
        let result = VMHooks::sha256(self, data_offset, length, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_sha256(&mut self, input_handle: i32, output_handle: i32) -> i32 {
        let result = VMHooks::managed_sha256(self, input_handle, output_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn keccak256(&mut self, data_offset: MemPtr, length: MemLength, result_offset: MemPtr) -> i32 {
        let result = VMHooks::keccak256(self, data_offset, length, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_keccak256(&mut self, input_handle: i32, output_handle: i32) -> i32 {
        let result = VMHooks::managed_keccak256(self, input_handle, output_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn ripemd160(&mut self, data_offset: MemPtr, length: MemLength, result_offset: MemPtr) -> i32 {
        let result = VMHooks::ripemd160(self, data_offset, length, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_ripemd160(&mut self, input_handle: i32, output_handle: i32) -> i32 {
        let result = VMHooks::managed_ripemd160(self, input_handle, output_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn verify_bls(&mut self, key_offset: MemPtr, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr) -> i32 {
        let result = VMHooks::verify_bls(self, key_offset, message_offset, message_length, sig_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_bls(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_verify_bls(self, key_handle, message_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn verify_ed25519(&mut self, key_offset: MemPtr, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr) -> i32 {
        let result = VMHooks::verify_ed25519(self, key_offset, message_offset, message_length, sig_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_ed25519(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_verify_ed25519(self, key_handle, message_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn verify_custom_secp256k1(&mut self, key_offset: MemPtr, key_length: MemLength, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr, hash_type: i32) -> i32 {
        let result = VMHooks::verify_custom_secp256k1(self, key_offset, key_length, message_offset, message_length, sig_offset, hash_type);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_custom_secp256k1(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32, hash_type: i32) -> i32 {
        let result = VMHooks::managed_verify_custom_secp256k1(self, key_handle, message_handle, sig_handle, hash_type);
        unwrap_or_set_breakpoint(self, result)
    }

    fn verify_secp256k1(&mut self, key_offset: MemPtr, key_length: MemLength, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr) -> i32 {
        let result = VMHooks::verify_secp256k1(self, key_offset, key_length, message_offset, message_length, sig_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_secp256k1(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_verify_secp256k1(self, key_handle, message_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn encode_secp256k1_der_signature(&mut self, r_offset: MemPtr, r_length: MemLength, s_offset: MemPtr, s_length: MemLength, sig_offset: MemPtr) -> i32 {
        let result = VMHooks::encode_secp256k1_der_signature(self, r_offset, r_length, s_offset, s_length, sig_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_encode_secp256k1_der_signature(&mut self, r_handle: i32, s_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_encode_secp256k1_der_signature(self, r_handle, s_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn add_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, fst_point_xhandle: i32, fst_point_yhandle: i32, snd_point_xhandle: i32, snd_point_yhandle: i32) {
        let result = VMHooks::add_ec(self, x_result_handle, y_result_handle, ec_handle, fst_point_xhandle, fst_point_yhandle, snd_point_xhandle, snd_point_yhandle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn double_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32) {
        let result = VMHooks::double_ec(self, x_result_handle, y_result_handle, ec_handle, point_xhandle, point_yhandle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn is_on_curve_ec(&mut self, ec_handle: i32, point_xhandle: i32, point_yhandle: i32) -> i32 {
        let result = VMHooks::is_on_curve_ec(self, ec_handle, point_xhandle, point_yhandle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn scalar_base_mult_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        let result = VMHooks::scalar_base_mult_ec(self, x_result_handle, y_result_handle, ec_handle, data_offset, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_scalar_base_mult_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32 {
        let result = VMHooks::managed_scalar_base_mult_ec(self, x_result_handle, y_result_handle, ec_handle, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn scalar_mult_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        let result = VMHooks::scalar_mult_ec(self, x_result_handle, y_result_handle, ec_handle, point_xhandle, point_yhandle, data_offset, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_scalar_mult_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32, data_handle: i32) -> i32 {
        let result = VMHooks::managed_scalar_mult_ec(self, x_result_handle, y_result_handle, ec_handle, point_xhandle, point_yhandle, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn marshal_ec(&mut self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_offset: MemPtr) -> i32 {
        let result = VMHooks::marshal_ec(self, x_pair_handle, y_pair_handle, ec_handle, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_marshal_ec(&mut self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_marshal_ec(self, x_pair_handle, y_pair_handle, ec_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn marshal_compressed_ec(&mut self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_offset: MemPtr) -> i32 {
        let result = VMHooks::marshal_compressed_ec(self, x_pair_handle, y_pair_handle, ec_handle, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_marshal_compressed_ec(&mut self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_marshal_compressed_ec(self, x_pair_handle, y_pair_handle, ec_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn unmarshal_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        let result = VMHooks::unmarshal_ec(self, x_result_handle, y_result_handle, ec_handle, data_offset, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_unmarshal_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32 {
        let result = VMHooks::managed_unmarshal_ec(self, x_result_handle, y_result_handle, ec_handle, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn unmarshal_compressed_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        let result = VMHooks::unmarshal_compressed_ec(self, x_result_handle, y_result_handle, ec_handle, data_offset, length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_unmarshal_compressed_ec(&mut self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32 {
        let result = VMHooks::managed_unmarshal_compressed_ec(self, x_result_handle, y_result_handle, ec_handle, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn generate_key_ec(&mut self, x_pub_key_handle: i32, y_pub_key_handle: i32, ec_handle: i32, result_offset: MemPtr) -> i32 {
        let result = VMHooks::generate_key_ec(self, x_pub_key_handle, y_pub_key_handle, ec_handle, result_offset);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_generate_key_ec(&mut self, x_pub_key_handle: i32, y_pub_key_handle: i32, ec_handle: i32, result_handle: i32) -> i32 {
        let result = VMHooks::managed_generate_key_ec(self, x_pub_key_handle, y_pub_key_handle, ec_handle, result_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn create_ec(&mut self, data_offset: MemPtr, data_length: MemLength) -> i32 {
        let result = VMHooks::create_ec(self, data_offset, data_length);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_create_ec(&mut self, data_handle: i32) -> i32 {
        let result = VMHooks::managed_create_ec(self, data_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_curve_length_ec(&mut self, ec_handle: i32) -> i32 {
        let result = VMHooks::get_curve_length_ec(self, ec_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn get_priv_key_byte_length_ec(&mut self, ec_handle: i32) -> i32 {
        let result = VMHooks::get_priv_key_byte_length_ec(self, ec_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn elliptic_curve_get_values(&mut self, ec_handle: i32, field_order_handle: i32, base_point_order_handle: i32, eq_constant_handle: i32, x_base_point_handle: i32, y_base_point_handle: i32) -> i32 {
        let result = VMHooks::elliptic_curve_get_values(self, ec_handle, field_order_handle, base_point_order_handle, eq_constant_handle, x_base_point_handle, y_base_point_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_secp256r1(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_verify_secp256r1(self, key_handle, message_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_blssignature_share(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_verify_blssignature_share(self, key_handle, message_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }

    fn managed_verify_blsaggregated_signature(&mut self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        let result = VMHooks::managed_verify_blsaggregated_signature(self, key_handle, message_handle, sig_handle);
        unwrap_or_set_breakpoint(self, result)
    }
}
