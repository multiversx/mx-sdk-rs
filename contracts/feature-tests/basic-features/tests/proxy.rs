// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct BasicFeaturesProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for BasicFeaturesProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = BasicFeaturesProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        BasicFeaturesProxyMethods { wrapped_tx: tx }
    }
}

pub struct BasicFeaturesProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> BasicFeaturesProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> BasicFeaturesProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn panic_with_message(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("panicWithMessage")
            .original_result()
    }

    /// Operation that has caused issues in the past 
    pub fn count_ones<
        Arg0: ProxyArg<u64>,
    >(
        self,
        arg: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("count_ones")
            .argument(&arg)
            .original_result()
    }

    pub fn endpoint_with_mutable_arg<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<u32>,
    >(
        self,
        arg1: Arg0,
        arg2: Arg1,
        arg3: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("endpoint_with_mutable_arg")
            .argument(&arg1)
            .argument(&arg2)
            .argument(&arg3)
            .original_result()
    }

    pub fn sqrt_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sqrt_big_uint")
            .argument(&a)
            .original_result()
    }

    pub fn sqrt_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sqrt_big_uint_ref")
            .argument(&a)
            .original_result()
    }

    pub fn log2_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("log2_big_uint")
            .argument(&a)
            .original_result()
    }

    pub fn log2_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("log2_big_uint_ref")
            .argument(&a)
            .original_result()
    }

    pub fn pow_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pow_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn pow_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pow_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn pow_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pow_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn pow_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pow_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn big_uint_to_u64<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        bu: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_to_u64")
            .argument(&bu)
            .original_result()
    }

    pub fn biguint_overwrite_u64<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        bu: Arg0,
        small: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("biguint_overwrite_u64")
            .argument(&bu)
            .argument(&small)
            .original_result()
    }

    pub fn big_uint_zero(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_zero")
            .original_result()
    }

    pub fn big_uint_from_u64_1<
        Arg0: ProxyArg<u64>,
    >(
        self,
        small: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_from_u64_1")
            .argument(&small)
            .original_result()
    }

    pub fn big_uint_from_u64_2<
        Arg0: ProxyArg<u64>,
    >(
        self,
        small: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_from_u64_2")
            .argument(&small)
            .original_result()
    }

    pub fn biguint_from_u128(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("biguint_from_u128")
            .original_result()
    }

    pub fn big_uint_from_managed_buffer<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        mb: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_from_managed_buffer")
            .argument(&mb)
            .original_result()
    }

    pub fn big_uint_from_managed_buffer_ref<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        mb: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_from_managed_buffer_ref")
            .argument(&mb)
            .original_result()
    }

    pub fn big_int_zero(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_int_zero")
            .original_result()
    }

    pub fn big_int_from_i64_1<
        Arg0: ProxyArg<i64>,
    >(
        self,
        small: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_int_from_i64_1")
            .argument(&small)
            .original_result()
    }

    pub fn big_int_from_i64_2<
        Arg0: ProxyArg<i64>,
    >(
        self,
        small: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_int_from_i64_2")
            .argument(&small)
            .original_result()
    }

    pub fn big_uint_eq_u64<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        bi: Arg0,
        small: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_uint_eq_u64")
            .argument(&bi)
            .argument(&small)
            .original_result()
    }

    pub fn big_int_to_i64<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<i64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_int_to_i64")
            .argument(&bi)
            .original_result()
    }

    pub fn bigint_overwrite_i64<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<i64>,
    >(
        self,
        bi: Arg0,
        small: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bigint_overwrite_i64")
            .argument(&bi)
            .argument(&small)
            .original_result()
    }

    pub fn big_int_to_parts<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<multiversx_sc::types::Sign, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_int_to_parts")
            .argument(&bi)
            .original_result()
    }

    pub fn big_int_from_biguint<
        Arg0: ProxyArg<multiversx_sc::types::Sign>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        sign: Arg0,
        unsigned: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("big_int_from_biguint")
            .argument(&sign)
            .argument(&unsigned)
            .original_result()
    }

    pub fn add_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_int_big_uint<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_int_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_uint_big_int<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_uint_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_int_big_uint_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_int_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_uint_big_int_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_uint_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_assign_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_assign_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_assign_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_assign_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn add_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_assign_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_assign_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_assign_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_assign_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sub_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sub_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_assign_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_assign_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_assign_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_assign_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn mul_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mul_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_assign_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_assign_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_assign_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_assign_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn div_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("div_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_assign_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_assign_big_int")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_assign_big_int_ref<
        Arg0: ProxyArg<BigInt<Env::Api>>,
        Arg1: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_assign_big_int_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn rem_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rem_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_and_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_and_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_and_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_and_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_or_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_or_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_or_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_or_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_xor_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_xor_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_xor_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_xor_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_and_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_and_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_and_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_and_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_or_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_or_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_or_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_or_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_xor_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_xor_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn bit_xor_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("bit_xor_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shr_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shr_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shr_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shr_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shl_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shl_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shl_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shl_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shr_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shr_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shr_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shr_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shl_assign_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shl_assign_big_uint")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn shl_assign_big_uint_ref<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("shl_assign_big_uint_ref")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn get_block_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_block_timestamp")
            .original_result()
    }

    pub fn get_block_nonce(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_block_nonce")
            .original_result()
    }

    pub fn get_block_round(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_block_round")
            .original_result()
    }

    pub fn get_block_epoch(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_block_epoch")
            .original_result()
    }

    pub fn get_block_random_seed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 48usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_block_random_seed")
            .original_result()
    }

    pub fn get_prev_block_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_prev_block_timestamp")
            .original_result()
    }

    pub fn get_prev_block_nonce(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_prev_block_nonce")
            .original_result()
    }

    pub fn get_prev_block_round(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_prev_block_round")
            .original_result()
    }

    pub fn get_prev_block_epoch(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_prev_block_epoch")
            .original_result()
    }

    pub fn get_prev_block_random_seed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 48usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_prev_block_random_seed")
            .original_result()
    }

    pub fn get_caller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_caller")
            .original_result()
    }

    pub fn get_owner_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_owner_address")
            .original_result()
    }

    pub fn get_shard_of_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_shard_of_address")
            .argument(&address)
            .original_result()
    }

    pub fn is_smart_contract<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("is_smart_contract")
            .argument(&address)
            .original_result()
    }

    pub fn get_state_root_hash(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 32usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_state_root_hash")
            .original_result()
    }

    pub fn get_tx_hash(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 32usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_tx_hash")
            .original_result()
    }

    pub fn get_gas_left(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_gas_left")
            .original_result()
    }

    pub fn get_cumulated_validator_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_cumulated_validator_rewards")
            .original_result()
    }

    pub fn get_code_metadata<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, CodeMetadata> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_code_metadata")
            .argument(&address)
            .original_result()
    }

    pub fn is_builtin_function<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        function_name: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("is_builtin_function")
            .argument(&function_name)
            .original_result()
    }

    pub fn codec_err_finish(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, CodecErrorTestType> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_finish")
            .original_result()
    }

    pub fn codec_err_storage_key(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_storage_key")
            .original_result()
    }

    pub fn codec_err_storage_get(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, CodecErrorTestType> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_storage_get")
            .original_result()
    }

    pub fn codec_err_storage_set(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_storage_set")
            .original_result()
    }

    pub fn codec_err_event_topic(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_event_topic")
            .original_result()
    }

    pub fn codec_err_event_data(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_event_data")
            .original_result()
    }

    /// Never actually calls any deploy/upgrade, so it is appropriate in this contract. 
    /// It just covers contract init serialization errors. 
    pub fn codec_err_contract_init(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_contract_init")
            .original_result()
    }

    /// Never actually calls any async/sync call, so it is appropriate in this contract. 
    /// It just covers contract call serialization errors. 
    pub fn codec_err_contract_call(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("codec_err_contract_call")
            .original_result()
    }

    pub fn compute_sha256<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        input: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 32usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_sha256")
            .argument(&input)
            .original_result()
    }

    pub fn compute_keccak256<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        input: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 32usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_keccak256")
            .argument(&input)
            .original_result()
    }

    pub fn compute_ripemd160<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        input: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedByteArray<Env::Api, 20usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_ripemd160")
            .argument(&input)
            .original_result()
    }

    pub fn verify_bls_signature<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        key: Arg0,
        message: Arg1,
        signature: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("verify_bls_signature")
            .argument(&key)
            .argument(&message)
            .argument(&signature)
            .original_result()
    }

    pub fn verify_ed25519_signature<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        key: Arg0,
        message: Arg1,
        signature: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("verify_ed25519_signature")
            .argument(&key)
            .argument(&message)
            .argument(&signature)
            .original_result()
    }

    pub fn verify_secp256k1_signature<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        key: Arg0,
        message: Arg1,
        signature: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("verify_secp256k1_signature")
            .argument(&key)
            .argument(&message)
            .argument(&signature)
            .original_result()
    }

    pub fn verify_custom_secp256k1_signature<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<MessageHashType>,
    >(
        self,
        key: Arg0,
        message: Arg1,
        signature: Arg2,
        hash_type: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("verify_custom_secp256k1_signature")
            .argument(&key)
            .argument(&message)
            .argument(&signature)
            .argument(&hash_type)
            .original_result()
    }

    pub fn compute_secp256k1_der_signature<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        r: Arg0,
        s: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_secp256k1_der_signature")
            .argument(&r)
            .argument(&s)
            .original_result()
    }

    pub fn echo_u64<
        Arg0: ProxyArg<u64>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_u64")
            .argument(&i)
            .original_result()
    }

    pub fn echo_i64<
        Arg0: ProxyArg<i64>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_i64")
            .argument(&i)
            .original_result()
    }

    pub fn echo_i32<
        Arg0: ProxyArg<i32>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_i32")
            .argument(&i)
            .original_result()
    }

    pub fn echo_u32<
        Arg0: ProxyArg<u32>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_u32")
            .argument(&i)
            .original_result()
    }

    pub fn echo_isize<
        Arg0: ProxyArg<isize>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, isize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_isize")
            .argument(&i)
            .original_result()
    }

    pub fn echo_usize<
        Arg0: ProxyArg<usize>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_usize")
            .argument(&i)
            .original_result()
    }

    pub fn echo_i8<
        Arg0: ProxyArg<i8>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_i8")
            .argument(&i)
            .original_result()
    }

    pub fn echo_u8<
        Arg0: ProxyArg<u8>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_u8")
            .argument(&i)
            .original_result()
    }

    pub fn echo_bool<
        Arg0: ProxyArg<bool>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_bool")
            .argument(&i)
            .original_result()
    }

    pub fn echo_opt_bool<
        Arg0: ProxyArg<Option<bool>>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<bool>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_opt_bool")
            .argument(&i)
            .original_result()
    }

    pub fn echo_nothing<
        Arg0: ProxyArg<()>,
    >(
        self,
        nothing: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_nothing")
            .argument(&nothing)
            .original_result()
    }

    pub fn echo_array_u8<
        Arg0: ProxyArg<[u8; 5]>,
    >(
        self,
        s: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, [u8; 5]> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_array_u8")
            .argument(&s)
            .original_result()
    }

    pub fn echo_multi_value_u32<
        Arg0: ProxyArg<MultiValueManagedVec<Env::Api, u32>>,
    >(
        self,
        m: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<usize, MultiValueManagedVec<Env::Api, u32>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_multi_value_u32")
            .argument(&m)
            .original_result()
    }

    pub fn echo_multi_value_tuples<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<isize, ManagedBuffer<Env::Api>>>>,
    >(
        self,
        m: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<isize, ManagedBuffer<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_multi_value_tuples")
            .argument(&m)
            .original_result()
    }

    pub fn echo_ser_example_2<
        Arg0: ProxyArg<ExampleEnumWithFields>,
    >(
        self,
        se: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ExampleEnumWithFields> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_ser_example_2")
            .argument(&se)
            .original_result()
    }

    pub fn echo_simple_enum<
        Arg0: ProxyArg<ExampleEnumSimple>,
    >(
        self,
        se: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ExampleEnumSimple> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_simple_enum")
            .argument(&se)
            .original_result()
    }

    pub fn finish_simple_enum_variant_1(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ExampleEnumSimple> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("finish_simple_enum_variant_1")
            .original_result()
    }

    pub fn echo_some_args_ignore_others<
        Arg0: ProxyArg<i32>,
        Arg1: ProxyArg<OptionalValue<i32>>,
        Arg2: ProxyArg<IgnoreValue>,
    >(
        self,
        i: Arg0,
        opt: Arg1,
        _ignore: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<i32, OptionalValue<i32>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_some_args_ignore_others")
            .argument(&i)
            .argument(&opt)
            .argument(&_ignore)
            .original_result()
    }

    pub fn echo_arrayvec<
        Arg0: ProxyArg<ArrayVec<i32, 3usize>>,
    >(
        self,
        av: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ArrayVec<i32, 3usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_arrayvec")
            .argument(&av)
            .original_result()
    }

    pub fn echo_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_big_uint")
            .argument(&bi)
            .original_result()
    }

    pub fn echo_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_big_int")
            .argument(&bi)
            .original_result()
    }

    pub fn echo_managed_buffer<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        mb: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_managed_buffer")
            .argument(&mb)
            .original_result()
    }

    pub fn echo_managed_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        ma: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_managed_address")
            .argument(&ma)
            .original_result()
    }

    /// This tests that nested serialization of big ints within unmanaged types works. 
    pub fn echo_big_int_managed_vec<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigInt<Env::Api>>>,
    >(
        self,
        x: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, BigInt<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_big_int_managed_vec")
            .argument(&x)
            .original_result()
    }

    /// This tests that nested serialization of big ints within unmanaged types works. 
    pub fn echo_big_int_tuple<
        Arg0: ProxyArg<(BigInt<Env::Api>, ManagedBuffer<Env::Api>)>,
    >(
        self,
        x: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigInt<Env::Api>, ManagedBuffer<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_big_int_tuple")
            .argument(&x)
            .original_result()
    }

    /// This tests that nested serialization of big ints within unmanaged types works. 
    pub fn echo_big_int_option<
        Arg0: ProxyArg<Option<BigInt<Env::Api>>>,
    >(
        self,
        x: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<BigInt<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_big_int_option")
            .argument(&x)
            .original_result()
    }

    pub fn echo_tuple_into_multiresult<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, ManagedBuffer<Env::Api>>>,
    >(
        self,
        addr: Arg0,
        vec: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<ManagedAddress<Env::Api>, ManagedVec<Env::Api, ManagedBuffer<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_tuple_into_multiresult")
            .argument(&addr)
            .argument(&vec)
            .original_result()
    }

    pub fn echo_managed_vec_of_managed_vec<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedVec<Env::Api, usize>>>,
    >(
        self,
        mv: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, ManagedVec<Env::Api, usize>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_managed_vec_of_managed_vec")
            .argument(&mv)
            .original_result()
    }

    pub fn echo_managed_vec_of_token_identifier<
        Arg0: ProxyArg<ManagedVec<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        mv: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_managed_vec_of_token_identifier")
            .argument(&mv)
            .original_result()
    }

    pub fn echo_managed_async_result_empty<
        Arg0: ProxyArg<ManagedAsyncCallResult<Env::Api, ()>>,
    >(
        self,
        a: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_managed_async_result_empty")
            .argument(&a)
            .original_result()
    }

    pub fn echo_varags_managed_eager<
        Arg0: ProxyArg<MultiValueManagedVec<Env::Api, u32>>,
    >(
        self,
        m: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<usize, MultiValueManagedVec<Env::Api, u32>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_varags_managed_eager")
            .argument(&m)
            .original_result()
    }

    pub fn echo_varags_managed_sum<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<u32, u32>>>,
    >(
        self,
        m: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue3<u32, u32, u32>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("echo_varags_managed_sum")
            .argument(&m)
            .original_result()
    }

    pub fn compute_get_values<
        Arg0: ProxyArg<u32>,
    >(
        self,
        curve_bitsize: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, u32)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_get_values")
            .argument(&curve_bitsize)
            .original_result()
    }

    pub fn compute_create_ec<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        curve: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, u32)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_create_ec")
            .argument(&curve)
            .original_result()
    }

    pub fn compute_get_ec_length<
        Arg0: ProxyArg<u32>,
    >(
        self,
        curve_bitsize: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_get_ec_length")
            .argument(&curve_bitsize)
            .original_result()
    }

    pub fn compute_get_priv_key_byte_length<
        Arg0: ProxyArg<u32>,
    >(
        self,
        curve_bitsize: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_get_priv_key_byte_length")
            .argument(&curve_bitsize)
            .original_result()
    }

    pub fn compute_ec_add<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        x_first_point: Arg1,
        y_first_point: Arg2,
        x_second_point: Arg3,
        y_second_point: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_ec_add")
            .argument(&curve_bitsize)
            .argument(&x_first_point)
            .argument(&y_first_point)
            .argument(&x_second_point)
            .argument(&y_second_point)
            .original_result()
    }

    pub fn compute_ec_double<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        x_point: Arg1,
        y_point: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_ec_double")
            .argument(&curve_bitsize)
            .argument(&x_point)
            .argument(&y_point)
            .original_result()
    }

    pub fn compute_is_on_curve_ec<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        x_point: Arg1,
        y_point: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_is_on_curve_ec")
            .argument(&curve_bitsize)
            .argument(&x_point)
            .argument(&y_point)
            .original_result()
    }

    pub fn compute_scalar_mult<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        x_point: Arg1,
        y_point: Arg2,
        data: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_scalar_mult")
            .argument(&curve_bitsize)
            .argument(&x_point)
            .argument(&y_point)
            .argument(&data)
            .original_result()
    }

    pub fn compute_scalar_base_mult<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        data: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_scalar_base_mult")
            .argument(&curve_bitsize)
            .argument(&data)
            .original_result()
    }

    pub fn compute_marshal_ec<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        x_pair: Arg1,
        y_pair: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_marshal_ec")
            .argument(&curve_bitsize)
            .argument(&x_pair)
            .argument(&y_pair)
            .original_result()
    }

    pub fn compute_marshal_compressed_ec<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        x_pair: Arg1,
        y_pair: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_marshal_compressed_ec")
            .argument(&curve_bitsize)
            .argument(&x_pair)
            .argument(&y_pair)
            .original_result()
    }

    pub fn compute_unmarshal_ec<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        data: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_unmarshal_ec")
            .argument(&curve_bitsize)
            .argument(&data)
            .original_result()
    }

    pub fn compute_unmarshal_compressed_ec<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        curve_bitsize: Arg0,
        data: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_unmarshal_compressed_ec")
            .argument(&curve_bitsize)
            .argument(&data)
            .original_result()
    }

    pub fn compute_generate_key_ec<
        Arg0: ProxyArg<u32>,
    >(
        self,
        curve_bitsize: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue3<BigUint<Env::Api>, BigUint<Env::Api>, ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("compute_generate_key_ec")
            .argument(&curve_bitsize)
            .original_result()
    }

    pub fn log_event_a<
        Arg0: ProxyArg<u32>,
    >(
        self,
        data: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("logEventA")
            .argument(&data)
            .original_result()
    }

    /// Logs `event_a` a repeated number of times. 
    pub fn log_event_a_repeat<
        Arg0: ProxyArg<u32>,
    >(
        self,
        num_logs: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("logEventARepeat")
            .argument(&num_logs)
            .original_result()
    }

    pub fn log_event_b<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<MultiValueManagedVec<Env::Api, ManagedBuffer<Env::Api>>>,
    >(
        self,
        arg1: Arg0,
        arg2: Arg1,
        data: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("logEventB")
            .argument(&arg1)
            .argument(&arg2)
            .argument(&data)
            .original_result()
    }

    pub fn only_owner_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("only_owner_endpoint")
            .original_result()
    }

    pub fn only_user_account_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("only_user_account_endpoint")
            .original_result()
    }

    pub fn require_equals<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        a: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("require_equals")
            .argument(&a)
            .argument(&b)
            .original_result()
    }

    pub fn sc_panic(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("sc_panic")
            .original_result()
    }

    pub fn maddress_from_array<
        Arg0: ProxyArg<[u8; 32]>,
    >(
        self,
        array: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("maddress_from_array")
            .argument(&array)
            .original_result()
    }

    pub fn maddress_from_managed_buffer<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        managed_buffer: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("maddress_from_managed_buffer")
            .argument(&managed_buffer)
            .original_result()
    }

    pub fn mbuffer_new(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mbuffer_new")
            .original_result()
    }

    pub fn mbuffer_concat<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        mb1: Arg0,
        mb2: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mbuffer_concat")
            .argument(&mb1)
            .argument(&mb2)
            .original_result()
    }

    pub fn mbuffer_copy_slice<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        mb: Arg0,
        starting_position: Arg1,
        slice_len: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<ManagedBuffer<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mbuffer_copy_slice")
            .argument(&mb)
            .argument(&starting_position)
            .argument(&slice_len)
            .original_result()
    }

    pub fn mbuffer_set_random<
        Arg0: ProxyArg<usize>,
    >(
        self,
        nr_bytes: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mbuffer_set_random")
            .argument(&nr_bytes)
            .original_result()
    }

    pub fn mbuffer_eq<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        mb1: Arg0,
        mb2: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mbuffer_eq")
            .argument(&mb1)
            .argument(&mb2)
            .original_result()
    }

    pub fn managed_address_zero(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_address_zero")
            .original_result()
    }

    pub fn managed_address_eq<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        mb1: Arg0,
        mb2: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_address_eq")
            .argument(&mb1)
            .argument(&mb2)
            .original_result()
    }

    pub fn managed_vec_new(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_new")
            .original_result()
    }

    pub fn managed_vec_biguint_push<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        mv: Arg0,
        item: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_biguint_push")
            .argument(&mv)
            .argument(&item)
            .original_result()
    }

    pub fn managed_vec_biguint_eq<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
    >(
        self,
        mv1: Arg0,
        mv2: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_biguint_eq")
            .argument(&mv1)
            .argument(&mv2)
            .original_result()
    }

    pub fn managed_vec_address_push<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        mv: Arg0,
        item: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_address_push")
            .argument(&mv)
            .argument(&item)
            .original_result()
    }

    pub fn managed_vec_set<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        mv: Arg0,
        index: Arg1,
        item: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_set")
            .argument(&mv)
            .argument(&index)
            .argument(&item)
            .original_result()
    }

    pub fn managed_vec_remove<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        mv: Arg0,
        index: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_remove")
            .argument(&mv)
            .argument(&index)
            .original_result()
    }

    pub fn managed_vec_find<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        mv: Arg0,
        item: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_find")
            .argument(&mv)
            .argument(&item)
            .original_result()
    }

    pub fn managed_vec_contains<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        mv: Arg0,
        item: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_vec_contains")
            .argument(&mv)
            .argument(&item)
            .original_result()
    }

    pub fn managed_ref_explicit<
        Arg0: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        mv: Arg0,
        index: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_ref_explicit")
            .argument(&mv)
            .argument(&index)
            .original_result()
    }

    pub fn storage_read_raw<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        storage_key: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("storage_read_raw")
            .argument(&storage_key)
            .original_result()
    }

    pub fn storage_write_raw<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        storage_key: Arg0,
        value: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("storage_write_raw")
            .argument(&storage_key)
            .argument(&value)
            .original_result()
    }

    pub fn storage_read_from_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        address: Arg0,
        storage_key: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("storage_read_from_address")
            .argument(&address)
            .argument(&storage_key)
            .original_result()
    }

    pub fn load_bytes(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_bytes")
            .original_result()
    }

    pub fn load_big_uint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_big_uint")
            .original_result()
    }

    pub fn load_big_int(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_big_int")
            .original_result()
    }

    pub fn load_u64(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_u64")
            .original_result()
    }

    pub fn load_usize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_usize")
            .original_result()
    }

    pub fn load_i64(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_i64")
            .original_result()
    }

    pub fn load_bool(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_bool")
            .original_result()
    }

    pub fn load_addr(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_addr")
            .original_result()
    }

    pub fn load_opt_addr(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_opt_addr")
            .original_result()
    }

    pub fn is_empty_opt_addr(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("is_empty_opt_addr")
            .original_result()
    }

    pub fn get_nr_to_clear(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_nr_to_clear")
            .original_result()
    }

    pub fn clear_storage_value(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clear_storage_value")
            .original_result()
    }

    pub fn load_ser_2(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ExampleEnumWithFields> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_ser_2")
            .original_result()
    }

    pub fn load_map1<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        addr: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_map1")
            .argument(&addr)
            .original_result()
    }

    pub fn load_map2<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        addr1: Arg0,
        addr2: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_map2")
            .argument(&addr1)
            .argument(&addr2)
            .original_result()
    }

    pub fn load_map3<
        Arg0: ProxyArg<usize>,
    >(
        self,
        x: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_map3")
            .argument(&x)
            .original_result()
    }

    pub fn load_from_address_raw<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        address: Arg0,
        key: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("load_from_address_raw")
            .argument(&address)
            .argument(&key)
            .original_result()
    }

    pub fn store_bytes<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_bytes")
            .argument(&bi)
            .original_result()
    }

    pub fn store_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_big_uint")
            .argument(&bi)
            .original_result()
    }

    pub fn store_big_int<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        bi: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_big_int")
            .argument(&bi)
            .original_result()
    }

    pub fn store_usize<
        Arg0: ProxyArg<usize>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_usize")
            .argument(&i)
            .original_result()
    }

    pub fn store_i32<
        Arg0: ProxyArg<i32>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_i32")
            .argument(&i)
            .original_result()
    }

    pub fn store_u64<
        Arg0: ProxyArg<u64>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_u64")
            .argument(&i)
            .original_result()
    }

    pub fn store_i64<
        Arg0: ProxyArg<i64>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_i64")
            .argument(&i)
            .original_result()
    }

    pub fn store_bool<
        Arg0: ProxyArg<bool>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_bool")
            .argument(&i)
            .original_result()
    }

    pub fn store_addr<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        arg: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_addr")
            .argument(&arg)
            .original_result()
    }

    pub fn store_opt_addr<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_addr: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_opt_addr")
            .argument(&opt_addr)
            .original_result()
    }

    pub fn store_ser_2<
        Arg0: ProxyArg<ExampleEnumWithFields>,
    >(
        self,
        arg: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_ser_2")
            .argument(&arg)
            .original_result()
    }

    pub fn store_map1<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        addr: Arg0,
        bi: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_map1")
            .argument(&addr)
            .argument(&bi)
            .original_result()
    }

    pub fn store_map2<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        addr1: Arg0,
        addr2: Arg1,
        bi: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_map2")
            .argument(&addr1)
            .argument(&addr2)
            .argument(&bi)
            .original_result()
    }

    pub fn store_map3<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<bool>,
    >(
        self,
        x: Arg0,
        b: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_map3")
            .argument(&x)
            .argument(&b)
            .original_result()
    }

    pub fn store_reserved_i64<
        Arg0: ProxyArg<i64>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_reserved_i64")
            .argument(&i)
            .original_result()
    }

    pub fn store_reserved_big_uint<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_reserved_big_uint")
            .argument(&i)
            .original_result()
    }

    pub fn store_reserved_vec_u8<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        i: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("store_reserved_vec_u8")
            .argument(&i)
            .original_result()
    }

    pub fn address_to_id_mapper_get_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_get_id")
            .argument(&address)
            .original_result()
    }

    pub fn address_to_id_mapper_get_id_non_zero<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_get_id_non_zero")
            .argument(&address)
            .original_result()
    }

    pub fn address_to_id_mapper_get_address<
        Arg0: ProxyArg<u64>,
    >(
        self,
        address_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_get_address")
            .argument(&address_id)
            .original_result()
    }

    pub fn address_to_id_mapper_contains<
        Arg0: ProxyArg<u64>,
    >(
        self,
        address_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_contains")
            .argument(&address_id)
            .original_result()
    }

    pub fn address_to_id_mapper_set<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_set")
            .argument(&address)
            .original_result()
    }

    pub fn address_to_id_mapper_get_id_or_insert<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_get_id_or_insert")
            .argument(&address)
            .original_result()
    }

    pub fn address_to_id_mapper_remove_by_id<
        Arg0: ProxyArg<u64>,
    >(
        self,
        address_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_remove_by_id")
            .argument(&address_id)
            .original_result()
    }

    pub fn address_to_id_mapper_remove_by_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("address_to_id_mapper_remove_by_address")
            .argument(&address)
            .original_result()
    }

    pub fn list_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getListMapper")
            .original_result()
    }

    pub fn list_mapper_push_back<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperPushBack")
            .argument(&item)
            .original_result()
    }

    pub fn list_mapper_push_front<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperPushFront")
            .argument(&item)
            .original_result()
    }

    pub fn list_mapper_pop_front(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperPopFront")
            .original_result()
    }

    pub fn list_mapper_pop_back(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperPopBack")
            .original_result()
    }

    pub fn list_mapper_front(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperFront")
            .original_result()
    }

    pub fn list_mapper_back(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperBack")
            .original_result()
    }

    pub fn list_mapper_push_after<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
        element: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperPushAfter")
            .argument(&node_id)
            .argument(&element)
            .original_result()
    }

    pub fn list_mapper_push_before<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
        element: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperPushBefore")
            .argument(&node_id)
            .argument(&element)
            .original_result()
    }

    pub fn list_mapper_remove_node<
        Arg0: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperRemoveNode")
            .argument(&node_id)
            .original_result()
    }

    pub fn list_mapper_remove_node_by_id<
        Arg0: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, OptionalValue<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperRemoveNodeById")
            .argument(&node_id)
            .original_result()
    }

    pub fn list_mapper_set_value<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
        new_value: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperSetValue")
            .argument(&node_id)
            .argument(&new_value)
            .original_result()
    }

    pub fn list_mapper_set_value_by_id<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
        new_value: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperSetValueById")
            .argument(&node_id)
            .argument(&new_value)
            .original_result()
    }

    pub fn list_mapper_iterate_by_hand<
        Arg0: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperIterateByHand")
            .argument(&node_id)
            .original_result()
    }

    pub fn list_mapper_iterate_by_iter<
        Arg0: ProxyArg<u32>,
    >(
        self,
        node_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("listMapperIterateByIter")
            .argument(&node_id)
            .original_result()
    }

    pub fn queue_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("queue_mapper")
            .original_result()
    }

    pub fn queue_mapper_push_back<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("queue_mapper_push_back")
            .argument(&item)
            .original_result()
    }

    pub fn queue_mapper_pop_front(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("queue_mapper_pop_front")
            .original_result()
    }

    pub fn queue_mapper_front(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("queue_mapper_front")
            .original_result()
    }

    pub fn map_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<u32, u32>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper")
            .original_result()
    }

    pub fn map_mapper_keys(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueManagedVec<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_keys")
            .original_result()
    }

    pub fn map_mapper_values(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueManagedVec<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_values")
            .original_result()
    }

    pub fn map_mapper_insert<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        value: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_insert")
            .argument(&item)
            .argument(&value)
            .original_result()
    }

    pub fn map_mapper_contains_key<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_contains_key")
            .argument(&item)
            .original_result()
    }

    pub fn map_mapper_get<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_get")
            .argument(&item)
            .original_result()
    }

    pub fn map_mapper_remove<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_remove")
            .argument(&item)
            .original_result()
    }

    pub fn map_mapper_entry_or_default_update_increment<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        increment: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_entry_or_default_update_increment")
            .argument(&item)
            .argument(&increment)
            .original_result()
    }

    pub fn map_mapper_entry_or_insert_default<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        default: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_entry_or_insert_default")
            .argument(&item)
            .argument(&default)
            .original_result()
    }

    pub fn map_mapper_entry_and_modify<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
        Arg2: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        increment: Arg1,
        otherwise: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_entry_and_modify")
            .argument(&item)
            .argument(&increment)
            .argument(&otherwise)
            .original_result()
    }

    pub fn map_mapper_entry_or_insert_with_key<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        key_increment: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_mapper_entry_or_insert_with_key")
            .argument(&item)
            .argument(&key_increment)
            .original_result()
    }

    pub fn map_storage_mapper_view(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_view")
            .original_result()
    }

    pub fn map_storage_mapper_insert_default<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_insert_default")
            .argument(&item)
            .original_result()
    }

    pub fn map_storage_mapper_contains_key<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_contains_key")
            .argument(&item)
            .original_result()
    }

    pub fn map_storage_mapper_get<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_get")
            .argument(&item)
            .original_result()
    }

    pub fn map_storage_mapper_insert_value<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
        Arg2: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        key: Arg1,
        value: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_insert_value")
            .argument(&item)
            .argument(&key)
            .argument(&value)
            .original_result()
    }

    pub fn map_storage_mapper_get_value<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        key: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_get_value")
            .argument(&item)
            .argument(&key)
            .original_result()
    }

    pub fn map_storage_mapper_remove<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_remove")
            .argument(&item)
            .original_result()
    }

    pub fn map_storage_mapper_clear(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_clear")
            .original_result()
    }

    pub fn map_storage_mapper_entry_or_default_update_increment<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
        Arg2: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        key: Arg1,
        increment: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_entry_or_default_update_increment")
            .argument(&item)
            .argument(&key)
            .argument(&increment)
            .original_result()
    }

    pub fn map_storage_mapper_entry_and_modify_increment_or_default<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
        Arg2: ProxyArg<u32>,
        Arg3: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        key: Arg1,
        value: Arg2,
        other: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_entry_and_modify_increment_or_default")
            .argument(&item)
            .argument(&key)
            .argument(&value)
            .argument(&other)
            .original_result()
    }

    pub fn map_storage_mapper_entry_or_default_update<
        Arg0: ProxyArg<u32>,
        Arg1: ProxyArg<u32>,
        Arg2: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
        key: Arg1,
        value: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_storage_mapper_entry_or_default_update")
            .argument(&item)
            .argument(&key)
            .argument(&value)
            .original_result()
    }

    pub fn set_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper")
            .original_result()
    }

    pub fn set_mapper_insert<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_insert")
            .argument(&item)
            .original_result()
    }

    pub fn set_mapper_contains<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_contains")
            .argument(&item)
            .original_result()
    }

    pub fn set_mapper_remove<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_remove")
            .argument(&item)
            .original_result()
    }

    pub fn set_mapper_front(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_front")
            .original_result()
    }

    pub fn set_mapper_back(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_back")
            .original_result()
    }

    pub fn set_mapper_next<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_next")
            .argument(&item)
            .original_result()
    }

    pub fn set_mapper_previous<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_previous")
            .argument(&item)
            .original_result()
    }

    pub fn set_mapper_iter_from_and_count<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_mapper_iter_from_and_count")
            .argument(&item)
            .original_result()
    }

    pub fn map_my_single_value_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigInt<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("map_my_single_value_mapper")
            .original_result()
    }

    pub fn my_single_value_mapper_increment_1<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("my_single_value_mapper_increment_1")
            .argument(&amount)
            .original_result()
    }

    /// Same as my_single_value_mapper_increment_1, but expressed more compactly. 
    pub fn my_single_value_mapper_increment_2<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("my_single_value_mapper_increment_2")
            .argument(&amount)
            .original_result()
    }

    pub fn my_single_value_mapper_subtract_with_require<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("my_single_value_mapper_subtract_with_require")
            .argument(&amount)
            .original_result()
    }

    pub fn my_single_value_mapper_set_if_empty<
        Arg0: ProxyArg<BigInt<Env::Api>>,
    >(
        self,
        value: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("my_single_value_mapper_set_if_empty")
            .argument(&value)
            .original_result()
    }

    pub fn clear_single_value_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clear_single_value_mapper")
            .original_result()
    }

    pub fn get_from_address_single_value_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_from_address_single_value_mapper")
            .original_result()
    }

    pub fn is_empty_single_value_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("is_empty_single_value_mapper")
            .original_result()
    }

    pub fn is_empty_at_address_single_value_mapper<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("is_empty_at_address_single_value_mapper")
            .argument(&address)
            .original_result()
    }

    pub fn raw_byte_length_single_value_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("raw_byte_length_single_value_mapper")
            .original_result()
    }

    pub fn vec_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vec_mapper")
            .original_result()
    }

    pub fn vec_mapper_push<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vec_mapper_push")
            .argument(&item)
            .original_result()
    }

    pub fn vec_mapper_get<
        Arg0: ProxyArg<usize>,
    >(
        self,
        index: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vec_mapper_get")
            .argument(&index)
            .original_result()
    }

    pub fn vec_mapper_get_at_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        address: Arg0,
        index: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vec_mapper_get_at_address")
            .argument(&address)
            .argument(&index)
            .original_result()
    }

    pub fn vec_mapper_len(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vec_mapper_len")
            .original_result()
    }

    pub fn vec_mapper_len_at_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vec_mapper_len_at_address")
            .argument(&address)
            .original_result()
    }

    pub fn token_attributes_set<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<TokenAttributesStruct<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        token_nonce: Arg1,
        attributes: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_attributes_set")
            .argument(&token_id)
            .argument(&token_nonce)
            .argument(&attributes)
            .original_result()
    }

    pub fn token_attributes_update<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<TokenAttributesStruct<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        token_nonce: Arg1,
        attributes: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_attributes_update")
            .argument(&token_id)
            .argument(&token_nonce)
            .argument(&attributes)
            .original_result()
    }

    pub fn token_attributes_get_attributes<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        token_id: Arg0,
        token_nonce: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenAttributesStruct<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_attributes_get_attributes")
            .argument(&token_id)
            .argument(&token_nonce)
            .original_result()
    }

    pub fn token_attributes_get_nonce<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenAttributesStruct<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        attributes: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_attributes_get_nonce")
            .argument(&token_id)
            .argument(&attributes)
            .original_result()
    }

    pub fn token_attributes_clear<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        token_id: Arg0,
        token_nonce: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_attributes_clear")
            .argument(&token_id)
            .argument(&token_nonce)
            .original_result()
    }

    pub fn token_attributes_has_attributes<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        token_id: Arg0,
        token_nonce: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_attributes_has_attributes")
            .argument(&token_id)
            .argument(&token_nonce)
            .original_result()
    }

    pub fn add_to_whitelist<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("add_to_whitelist")
            .argument(&item)
            .original_result()
    }

    pub fn remove_from_whitelist<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("remove_from_whitelist")
            .argument(&item)
            .original_result()
    }

    pub fn check_contains<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("check_contains")
            .argument(&item)
            .original_result()
    }

    pub fn check_contains_at_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        address: Arg0,
        item: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("check_contains_at_address")
            .argument(&address)
            .argument(&item)
            .original_result()
    }

    pub fn require_contains<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("require_contains")
            .argument(&item)
            .original_result()
    }

    pub fn require_contains_at_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        address: Arg0,
        item: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("require_contains_at_address")
            .argument(&address)
            .argument(&item)
            .original_result()
    }

    pub fn issue_fungible_default_callback<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_ticker: Arg0,
        initial_supply: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issue_fungible_default_callback")
            .argument(&token_ticker)
            .argument(&initial_supply)
            .original_result()
    }

    pub fn issue_fungible_custom_callback<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_ticker: Arg0,
        initial_supply: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issue_fungible_custom_callback")
            .argument(&token_ticker)
            .argument(&initial_supply)
            .original_result()
    }

    pub fn issue_and_set_all_roles_fungible<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_ticker: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issue_and_set_all_roles_fungible")
            .argument(&token_ticker)
            .original_result()
    }

    pub fn set_local_roles_fungible(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_local_roles_fungible")
            .original_result()
    }

    pub fn mint_fungible<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mint_fungible")
            .argument(&amount)
            .original_result()
    }

    pub fn mint_and_send_fungible<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        to: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mint_and_send_fungible")
            .argument(&to)
            .argument(&amount)
            .original_result()
    }

    pub fn burn_fungible<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("burn_fungible")
            .argument(&amount)
            .original_result()
    }

    pub fn get_balance_fungible(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_balance_fungible")
            .original_result()
    }

    pub fn require_same_token_fungible(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("require_same_token_fungible")
            .original_result()
    }

    pub fn require_all_same_token_fungible(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("require_all_same_token_fungible")
            .original_result()
    }

    pub fn fungible_token_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFungibleTokenId")
            .original_result()
    }

    pub fn issue_and_set_all_roles_meta<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_ticker: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issue_and_set_all_roles_meta")
            .argument(&token_ticker)
            .original_result()
    }

    pub fn mapper_nft_set_token_id<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_set_token_id")
            .argument(&token_id)
            .original_result()
    }

    pub fn mapper_nft_create<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<RgbColor>,
    >(
        self,
        amount: Arg0,
        attributes: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_create")
            .argument(&amount)
            .argument(&attributes)
            .original_result()
    }

    pub fn mapper_nft_create_and_send<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<RgbColor>,
    >(
        self,
        to: Arg0,
        amount: Arg1,
        attributes: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_create_and_send")
            .argument(&to)
            .argument(&amount)
            .argument(&attributes)
            .original_result()
    }

    pub fn mapper_nft_add_quantity<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_nonce: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_add_quantity")
            .argument(&token_nonce)
            .argument(&amount)
            .original_result()
    }

    pub fn mapper_nft_add_quantity_and_send<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        to: Arg0,
        token_nonce: Arg1,
        amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_add_quantity_and_send")
            .argument(&to)
            .argument(&token_nonce)
            .argument(&amount)
            .original_result()
    }

    pub fn mapper_nft_burn<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_nonce: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_burn")
            .argument(&token_nonce)
            .argument(&amount)
            .original_result()
    }

    pub fn mapper_nft_get_balance<
        Arg0: ProxyArg<u64>,
    >(
        self,
        token_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_nft_get_balance")
            .argument(&token_nonce)
            .original_result()
    }

    pub fn mapper_get_token_attributes<
        Arg0: ProxyArg<u64>,
    >(
        self,
        token_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RgbColor> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mapper_get_token_attributes")
            .argument(&token_nonce)
            .original_result()
    }

    pub fn non_fungible_token_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNonFungibleTokenId")
            .original_result()
    }

    pub fn init_unique_id_mapper<
        Arg0: ProxyArg<usize>,
    >(
        self,
        len: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("init_unique_id_mapper")
            .argument(&len)
            .original_result()
    }

    pub fn unique_id_mapper_get<
        Arg0: ProxyArg<usize>,
    >(
        self,
        index: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unique_id_mapper_get")
            .argument(&index)
            .original_result()
    }

    pub fn unique_id_mapper_swap_remove<
        Arg0: ProxyArg<usize>,
    >(
        self,
        index: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unique_id_mapper_swap_remove")
            .argument(&index)
            .original_result()
    }

    pub fn unique_id_mapper_set<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        index: Arg0,
        id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unique_id_mapper_set")
            .argument(&index)
            .argument(&id)
            .original_result()
    }

    pub fn unique_id_mapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unique_id_mapper")
            .original_result()
    }

    pub fn managed_struct_eq<
        Arg0: ProxyArg<ExampleStructManaged<Env::Api>>,
        Arg1: ProxyArg<ExampleStructManaged<Env::Api>>,
    >(
        self,
        s1: Arg0,
        s2: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_struct_eq")
            .argument(&s1)
            .argument(&s2)
            .original_result()
    }

    pub fn no_overflow_usize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_usize")
            .original_result()
    }

    pub fn no_overflow_u8(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_u8")
            .original_result()
    }

    pub fn no_overflow_u16(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u16> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_u16")
            .original_result()
    }

    pub fn no_overflow_u32(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_u32")
            .original_result()
    }

    pub fn no_overflow_u64(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_u64")
            .original_result()
    }

    pub fn overflow_usize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_usize")
            .original_result()
    }

    pub fn overflow_u8(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_u8")
            .original_result()
    }

    pub fn overflow_u16(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u16> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_u16")
            .original_result()
    }

    pub fn overflow_u32(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_u32")
            .original_result()
    }

    pub fn overflow_u64(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_u64")
            .original_result()
    }

    pub fn no_overflow_isize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, isize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_isize")
            .original_result()
    }

    pub fn no_overflow_i8(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_i8")
            .original_result()
    }

    pub fn no_overflow_i16(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i16> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_i16")
            .original_result()
    }

    pub fn no_overflow_i32(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_i32")
            .original_result()
    }

    pub fn no_overflow_i64(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("no_overflow_i64")
            .original_result()
    }

    pub fn overflow_isize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, isize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_isize")
            .original_result()
    }

    pub fn overflow_i8(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_i8")
            .original_result()
    }

    pub fn overflow_i16(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i16> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_i16")
            .original_result()
    }

    pub fn overflow_i32(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_i32")
            .original_result()
    }

    pub fn overflow_i64(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, i64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("overflow_i64")
            .original_result()
    }

    pub fn token_identifier_egld(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_identifier_egld")
            .original_result()
    }

    pub fn token_identifier_is_valid_1<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_identifier_is_valid_1")
            .argument(&token_id)
            .original_result()
    }

    pub fn token_identifier_is_valid_2<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        bytes: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("token_identifier_is_valid_2")
            .argument(&bytes)
            .original_result()
    }

    pub fn returns_egld_decimal(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ManagedDecimal<Env::Api, ConstDecimals<18>>> {
        self.wrapped_tx
            .raw_call("returns_egld_decimal")
            .original_result()
    }

    pub fn set_contract_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("set_contract_address")
            .argument(&address)
            .original_result()
    }

    pub fn is_empty_at_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("is_empty_at_address")
            .original_result()
    }

    pub fn contains_at_address<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("contains_at_address")
            .argument(&item)
            .original_result()
    }

    pub fn len_at_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("len_at_address")
            .original_result()
    }

    pub fn next_at_address<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("next_at_address")
            .argument(&item)
            .original_result()
    }

    pub fn previous_at_address<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("previous_at_address")
            .argument(&item)
            .original_result()
    }

    pub fn front_at_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("front_at_address")
            .original_result()
    }

    pub fn back_at_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("back_at_address")
            .original_result()
    }

    pub fn keys_at_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("keys_at_address")
            .original_result()
    }

    pub fn values_at_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, u32>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("values_at_address")
            .original_result()
    }

    pub fn contains_unordered_at_address<
        Arg0: ProxyArg<u32>,
    >(
        self,
        item: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("contains_unordered_at_address")
            .argument(&item)
            .original_result()
    }

    pub fn get_by_index<
        Arg0: ProxyArg<usize>,
    >(
        self,
        index: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_by_index")
            .argument(&index)
            .original_result()
    }

    pub fn fill_set_mapper<
        Arg0: ProxyArg<u32>,
    >(
        self,
        value: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("fill_set_mapper")
            .argument(&value)
            .original_result()
    }

    pub fn fill_map_mapper<
        Arg0: ProxyArg<u32>,
    >(
        self,
        value: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("fill_map_mapper")
            .argument(&value)
            .original_result()
    }

    pub fn fill_unordered_set_mapper<
        Arg0: ProxyArg<u32>,
    >(
        self,
        value: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("fill_unordered_set_mapper")
            .argument(&value)
            .original_result()
    }

    pub fn managed_decimal_addition<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, ConstDecimals<2>>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, ConstDecimals<2>>>,
    >(
        self,
        first: Arg0,
        second: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, ConstDecimals<2>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_decimal_addition")
            .argument(&first)
            .argument(&second)
            .original_result()
    }

    pub fn managed_decimal_subtraction<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, ConstDecimals<2>>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, ConstDecimals<2>>>,
    >(
        self,
        first: Arg0,
        second: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, ConstDecimals<2>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_decimal_subtraction")
            .argument(&first)
            .argument(&second)
            .original_result()
    }

    pub fn managed_decimal_eq<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, ConstDecimals<2>>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, ConstDecimals<2>>>,
    >(
        self,
        first: Arg0,
        second: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_decimal_eq")
            .argument(&first)
            .argument(&second)
            .original_result()
    }

    pub fn managed_decimal_trunc(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_decimal_trunc")
            .original_result()
    }

    pub fn managed_decimal_into_raw_units(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("managed_decimal_into_raw_units")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct CodecErrorTestType {}

#[rustfmt::skip]
#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum ExampleEnumWithFields {
    Unit,
    Newtype(u32),
    Tuple(u32, u32),
    Struct {
        a: u32,
    },
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum ExampleEnumSimple {
    Variant0,
    Variant1,
    Variant2,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct TokenAttributesStruct<Api>
where
    Api: ManagedTypeApi,
{
    pub field_biguint: BigUint<Api>,
    pub field_u64: u64,
    pub field_vec_u32: ManagedVec<Api, u32>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct RgbColor {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct ExampleStructManaged<Api>
where
    Api: ManagedTypeApi,
{
    pub big_uint: BigUint<Api>,
    pub int: u32,
    pub bytes: ManagedBuffer<Api>,
}
