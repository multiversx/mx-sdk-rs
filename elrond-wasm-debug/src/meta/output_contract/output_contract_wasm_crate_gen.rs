use std::{
    fs::{self, File},
    io::Write,
    path::PathBuf,
};

use super::OutputContract;

const PREFIX_AUTO_GENERATED: &str =
    "// Code generated by the elrond-wasm multi-contract system. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

";

const PREFIX_NO_STD: &str = "

#![no_std]

";

fn write_endpoints_macro<'a, I>(
    full_macro_name: &str,
    wasm_lib_file: &mut File,
    contract_module_name: &str,
    endpoint_names: I,
) where
    I: Iterator<Item = &'a String>,
{
    writeln!(wasm_lib_file, "{} {{", full_macro_name).unwrap();
    writeln!(wasm_lib_file, "    {}", contract_module_name).unwrap();
    writeln!(wasm_lib_file, "    (").unwrap();
    for endpoint_name in endpoint_names {
        writeln!(wasm_lib_file, "        {}", endpoint_name).unwrap();
    }
    writeln!(wasm_lib_file, "    )").unwrap();
    writeln!(wasm_lib_file, "}}").unwrap();
}

fn write_wasm_empty_callback_macro(wasm_lib_file: &mut File) {
    writeln!(wasm_lib_file).unwrap();
    writeln!(wasm_lib_file, "elrond_wasm_node::wasm_empty_callback! {{}}").unwrap();
}

impl OutputContract {
    fn write_wasm_src_lib_contents(&self, wasm_lib_file: &mut File) {
        let endpoint_names = self.endpoint_names();
        wasm_lib_file
            .write_all(PREFIX_AUTO_GENERATED.as_bytes())
            .unwrap();
        write!(
            wasm_lib_file,
            "// Number of endpoints: {}",
            endpoint_names.len()
        )
        .unwrap();
        wasm_lib_file.write_all(PREFIX_NO_STD.as_bytes()).unwrap();

        let full_macro_name = if self.external_view {
            "elrond_wasm_node::external_view_wasm_endpoints!"
        } else {
            "elrond_wasm_node::wasm_endpoints!"
        };

        let mut mandatory_endpoints = Vec::new();
        if self.abi.has_callback {
            mandatory_endpoints.push("callBack".to_string());
        }
        let all_endpoint_names = mandatory_endpoints.iter().chain(endpoint_names.iter());

        let contract_module_name = self.abi.get_crate_name_for_code();
        write_endpoints_macro(
            full_macro_name,
            wasm_lib_file,
            &contract_module_name,
            all_endpoint_names,
        );

        if !self.abi.has_callback {
            write_wasm_empty_callback_macro(wasm_lib_file);
        }
    }

    pub fn create_wasm_crate_dir(&self) {
        fs::create_dir_all(PathBuf::from(&self.wasm_crate_path()).join("src")).unwrap();
    }

    pub fn generate_wasm_src_lib_file(&self) {
        let lib_path = format!("{}/src/lib.rs", &self.wasm_crate_path());
        let mut wasm_lib_file = File::create(lib_path).unwrap();
        self.write_wasm_src_lib_contents(&mut wasm_lib_file);
    }
}
