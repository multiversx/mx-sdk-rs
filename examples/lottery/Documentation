Initial deployment requires no arguments. Once the deployment is complete, anyone can start a lottery with their preferred settings.

To start a lottery, the following function has to be called:

fn start(lottery_name: Vec<u8>,
        ticket_price: BigUint, 
        total_tickets: Option<u32>, 
        deadline: Option<u64>,
        max_entries_per_user: Option<u32>,
        prize_distribution: Option<Vec<u8>>,
        whitelist: Option<Vec<Address>>) 
        
Arguments: (Note: Optional arguments still have to be passed. 
		If you want to skip an argument, pass 0x as value.
		If you want to use that argument, pass 0x01, followed by the value - both concatenated.
		Example: Option<u32> want to pass 4 as value, pass 0x0100000004)

- lottery_name: Each lottery has to have a unique name, using ASCII characters only.
- ticket_price: The price of the ticket in ERD wei (1 ERD/eGLD = 10^18 ERD wei). For example, 2000000000000000000 for 2 eGLD ticket price.
- total_ticket (Optional): The total available tickets for the lottery. If they're sold out, the lottery can be ended. Default is "unlimited"
- deadline (Optional): The deadline for the lottery, expressed as timestamp. The default and the maximum is 30 days in the future.
- max_entries_per_user (Optional): The max number of tickets each user can buy. The default is unlimited.
- prize_distribution (Optional): An array of unsigned integer values that add up to exactly 100 (%). Example: [75, 15, 10]
	[0] -> 1st ticket winner prize (75% of total pool)
	[1] -> 2nd ticket winner prize (15% of total pool)
	[2] -> 3rd ticket winner prize (10% of total pool)
- whitelist (Optional): If provided, only the addresses on the list can participate in this lottery.

-----------------------------------------------------------------------------------------------------------------------------------

Command example. Create lottery with the name 0x5555, 2 eGLD ticket price, 4 tickets total

erdpy --verbose contract call ***contract address*** \
 --recall-nonce --gas-limit=20000000 --function=start \
 --keyfile=***private key file*** \
 --passfile=***password for private key file*** --outfile=***output file path*** \
 --chain="T" --proxy="https://api-testnet.elrond.com" \
 --send --arguments 0x5555 2000000000000000000 0x0100000004 0x 0x 0x 0x
 
-----------------------------------------------------------------------------------------------------------------------------------
        
Once a lottery has been started, other people can start buying tickets for that lottery, using the following function:        

fn buy_ticket(lottery_name: Vec<u8>, #[payment] _payment: BigUint)

All you need to do is pay the appropriate ticket price and pass along the lottery you wish to join.

-----------------------------------------------------------------------------------------------------------------------------------

Once all the tickets have been sold out or the deadline has passed, anyone can call this function.
The winners will be randomly decided and the prizes sent out automatically.

fn determine_winner(lottery_name: Vec<u8>)

Just pass along the lottery name.

-----------------------------------------------------------------------------------------------------------------------------------

If you're unsure whether a lottery exists, is running, or is waiting to send out prizes, you can check the status using the following function:

fn status(&self, lottery_name: Vec<u8>)

The function will return:
0 -> Inactive (doesn't exist)
1 -> Running (is currently selling tickets)
2 -> Ended (is waiting for someone to call the determine_winner function)

-----------------------------------------------------------------------------------------------------------------------------------

#[view] functions:

fn get_deadline(&self, lottery_name: &Vec<u8>) -> u64;

fn get_ticket_price(&self, lottery_name: &Vec<u8>) -> BigUint;

fn get_mut_tickets_left(&self, lottery_name: &Vec<u8>) -> mut_storage!(u32);

fn get_mut_prize_pool(&self, lottery_name: &Vec<u8>) -> mut_storage!(BigUint);

fn get_max_entries_per_user(&self, lottery_name: &Vec<u8>) -> u32;

fn get_prize_distribution(&self, lottery_name: &Vec<u8>) -> Vec<u8>;

fn get_whitelist(&self, lottery_name: &Vec<u8>) -> Vec<Address>;

-----------------------------------------------------------------------------------------------------------------------------------
