use std::fmt::Write;

pub struct OpInfo {
    pub name: &'static str,
    pub operator: &'static str,
}

pub const OPS: &[OpInfo] = &[
    OpInfo {
        name: "add",
        operator: "+",
    },
    OpInfo {
        name: "sub",
        operator: "-",
    },
    OpInfo {
        name: "mul",
        operator: "*",
    },
    OpInfo {
        name: "div",
        operator: "/",
    },
    OpInfo {
        name: "rem",
        operator: "%",
    },
];

pub const BITWISE_OPS: &[OpInfo] = &[
    OpInfo {
        name: "bit_and",
        operator: "&",
    },
    OpInfo {
        name: "bit_or",
        operator: "|",
    },
    OpInfo {
        name: "bit_xor",
        operator: "^",
    },
];

pub const SHIFT_OPS: &[OpInfo] = &[
    OpInfo {
        name: "shr",
        operator: ">>",
    },
    OpInfo {
        name: "shl",
        operator: "<<",
    },
];

fn write_bin_op_endpoint(
    out: &mut String,
    op: &OpInfo,
    fn_name_suffix: &str,
    a_type: &str,
    b_type: &str,
    return_type: &str,
) {
    write!(
        out,
        "
    #[endpoint]
    fn {name}_{fn_name_suffix}(&self, a: {a_type}, b: {b_type}) -> {return_type} {{
        a {op} b
    }}",
        name = op.name,
        op = op.operator
    )
    .unwrap();
}

fn write_assign_endpoint(
    out: &mut String,
    op: &OpInfo,
    fn_name_suffix: &str,
    a_type: &str,
    b_type: &str,
    return_type: &str,
) {
    write!(
        out,
        "
    #[endpoint]
    fn {name}_assign_{fn_name_suffix}(&self, a: {a_type}, b: {b_type}) -> {return_type} {{
        let mut r = a.clone();
        r {op}= b;
        r
    }}",
        name = op.name,
        op = op.operator
    )
    .unwrap();
}

fn section_comment(out: &mut String, comment: &str) {
    writeln!(out, "\n\n    // {}", comment).unwrap();
}

/// Generates a Rust trait similar to BigIntOperators, with methods for each operator in OPS.
pub fn generate_big_int_operators_trait() -> String {
    let mut out = BIG_NUM_OPERATORS_PRELUDE.to_string();

    section_comment(&mut out, "Arithmetic binary operators");

    for op in OPS {
        write_bin_op_endpoint(&mut out, op, "big_int", "BigInt", "BigInt", "BigInt");
        write_bin_op_endpoint(&mut out, op, "big_int_ref", "&BigInt", "&BigInt", "BigInt");
        write_bin_op_endpoint(&mut out, op, "big_uint", "BigUint", "BigUint", "BigUint");
        write_bin_op_endpoint(
            &mut out,
            op,
            "big_uint_ref",
            "&BigUint",
            "&BigUint",
            "BigUint",
        );
    }

    section_comment(&mut out, "Arithmetic assign operators");

    for op in OPS {
        write_assign_endpoint(&mut out, op, "big_int", "BigInt", "BigInt", "BigInt");
        write_assign_endpoint(&mut out, op, "big_int_ref", "&BigInt", "&BigInt", "BigInt");
        write_assign_endpoint(&mut out, op, "big_uint", "BigUint", "BigUint", "BigUint");
        write_assign_endpoint(
            &mut out,
            op,
            "big_uint_ref",
            "&BigUint",
            "&BigUint",
            "BigUint",
        );
    }

    section_comment(&mut out, "Bitwise binary operators");

    for op in BITWISE_OPS {
        write_bin_op_endpoint(&mut out, op, "big_uint", "BigUint", "BigUint", "BigUint");
        write_bin_op_endpoint(
            &mut out,
            op,
            "big_uint_ref",
            "&BigUint",
            "&BigUint",
            "BigUint",
        );
    }

    section_comment(&mut out, "Bitwise assign operators");

    for op in BITWISE_OPS {
        write_assign_endpoint(&mut out, op, "big_uint", "BigUint", "BigUint", "BigUint");
        write_assign_endpoint(
            &mut out,
            op,
            "big_uint_ref",
            "&BigUint",
            "&BigUint",
            "BigUint",
        );
    }

    section_comment(&mut out, "Bitwise shift binary operators");

    for op in SHIFT_OPS {
        write_bin_op_endpoint(&mut out, op, "big_uint", "BigUint", "usize", "BigUint");
        write_bin_op_endpoint(&mut out, op, "big_uint_ref", "&BigUint", "usize", "BigUint");
    }

    section_comment(&mut out, "Bitwise shift assign operators");

    for op in SHIFT_OPS {
        write_assign_endpoint(&mut out, op, "big_uint", "BigUint", "usize", "BigUint");
        write_assign_endpoint(&mut out, op, "big_uint_ref", "&BigUint", "usize", "BigUint");
    }

    writeln!(&mut out, "\n}}").unwrap();

    out
}

const BIG_NUM_OPERATORS_PRELUDE: &str = r#"// Code generated by tools/op-test-gen crate. DO NOT EDIT.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!! AUTO-GENERATED FILE !!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

multiversx_sc::imports!();

/// Checks that BigUint/BigInt operators work as expected.
#[multiversx_sc::module]
#[allow(clippy::redundant_clone)]
pub trait BigIntOperators {
    // Endpoints grouped into several sections:"#;
